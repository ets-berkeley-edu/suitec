/**
 * Copyright Â©2016. The Regents of the University of California (Regents). All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its documentation
 * for educational, research, and not-for-profit purposes, without fee and without a
 * signed licensing agreement, is hereby granted, provided that the above copyright
 * notice, this paragraph and the following two paragraphs appear in all copies,
 * modifications, and distributions.
 *
 * Contact The Office of Technology Licensing, UC Berkeley, 2150 Shattuck Avenue,
 * Suite 510, Berkeley, CA 94720-1620, (510) 643-7201, otl@berkeley.edu,
 * http://ipira.berkeley.edu/industry-info for commercial licensing opportunities.
 *
 * IN NO EVENT SHALL REGENTS BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL,
 * INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING LOST PROFITS, ARISING OUT OF
 * THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF REGENTS HAS BEEN ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * REGENTS SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
 * SOFTWARE AND ACCOMPANYING DOCUMENTATION, IF ANY, PROVIDED HEREUNDER IS PROVIDED
 * "AS IS". REGENTS HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 * ENHANCEMENTS, OR MODIFICATIONS.
 */

var _ = require('lodash');
var config = require('config');
var Sequelize = require('sequelize');

var ActivitiesDefaults = require('col-activities/lib/default');

var CollabosphereConstants = require('./constants');
var log = require('./logger')('col-core/db');

// A sequelize instance that will be connected to the database
var sequelize = null;

/**
 * Initialize the database and the Collabosphere models
 *
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var init = module.exports.init = function(callback) {
  var sequelizeConfig = {
    'host': config.get('db.host'),
    'port': config.get('db.port'),
    'dialect': 'postgres',
    'databaseVersion': config.get('db.version'),
    'logging': function(msg) {
      log.trace(msg);
    }
  };

  // Set up a connection to the database
  sequelize = new Sequelize(config.get('db.database'), config.get('db.username'), config.get('db.password'), sequelizeConfig);

  sequelize.authenticate().complete(function(err) {
    if (err) {
      log.error({'err': err}, 'Unable to set up a connection to the database');
      return callback({'code': 500, 'msg': 'Unable to set up a connection to the database'});
    }

    log.debug('Connected to the database');

    // Set up the model
    setUpModel(sequelize);

    // Synchronize the Collabosphere models with the database
    return sync(callback);
  });
};

/**
 * Synchronize the Collabosphere models with the database
 *
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error object, if any
 */
var sync = function(callback) {
  // Allow model synchronization to be skipped. This is useful in production so a user without
  // table modification rights can be configured
  if (config.get('db.sync') === false) {
    log.debug('Skipping DB synchronization');
    return callback();
  }

  // By setting `force` to `true` we will drop each table and recreate it. This is useful
  // during development/testing when models tend to change. We NEVER do this in production though
  var force = false;
  if (process.env.NODE_ENV !== 'production' && config.get('db.dropOnStartup') === true) {
    force = true;
  }

  sequelize.sync({'force': force}).complete(function(err) {
    if (err) {
      log.error({'err': err}, 'Unable to sync the model to the database');
      return callback({'code': 500, 'msg': 'Unable to sync the model to the database'});
    }

    log.debug('Synced model to database');

    return callback();
  });
};

/**
 * Get the `Sequelize` object
 *
 * @return {Sequelize}                                A sequelize instance that is connected to the database
 */
var getSequelize = module.exports.getSequelize = function() {
  return sequelize;
};

/**
 * Set up the DB model
 *
 * @param  {Sequelize}        sequelize               A sequelize instance that is connected to the database
 * @api private
 */
var setUpModel = function(sequelize) {

  /**
   * The `canvas` table keeps track of the Canvas instances that Collabosphere should
   * communicate with. It holds all the information that's needed to interact with the
   * Canvas API and to embed the Collabosphere tools into Canvas
   *
   * @property  {String}      canvas_api_domain       The domain on which Canvas is running
   * @property  {String}      api_key                 The key that can be used to interact with the Canvas API
   * @property  {String}      lti_key                 The basic LTI key that will be used to embed the tools into Canvas
   * @property  {String}      lti_secret              The basic LTI secret that will be used to embed the tools into Canvas
   * @property  {Boolean}     use_https               Whether the Canvas API is running on https
   * @property  {String}      name                    The name of the service that is running on Canvas (e.g., bCourses)
   * @property  {String}      logo                    A URL to the logo of the service that is running on Canvas (e.g., a URL to the bCourses logo)
   */
  var Canvas = module.exports.Canvas = sequelize.define('canvas', {
    'canvas_api_domain': {
      'type': Sequelize.STRING,
      'allowNull': false,
      'primaryKey': true
    },
    'api_key': {
      'type': Sequelize.STRING,
      'allowNull': false
    },
    'lti_key': {
      'type': Sequelize.STRING,
      'allowNull': false,
      'unique': true
    },
    'lti_secret': {
      'type': Sequelize.STRING,
      'allowNull': false,
      'unique': true
    },
    'use_https': {
      'type': Sequelize.BOOLEAN,
      'defaultValue': true
    },
    'name': {
      'type': Sequelize.STRING,
      'allowNull': true
    },
    'logo': {
      'type': Sequelize.STRING,
      'allowNull': true
    }
  }, {
    'tableName': 'canvas',
    'underscored': true,
    'instanceMethods': {
      'toJSON': function() {
        var canvas = _.clone(this.dataValues);

        // Delete the sensitive values
        delete canvas.api_key;
        delete canvas.lti_key;
        delete canvas.lti_secret;

        return canvas;
      }
    }
  });

  /**
   * The `course` table keeps track of each course in which one of the tools has been embedded
   *
   * @property  {Number}      canvas_course_id        The id of the course in Canvas
   * @property  {Boolean}     enable_upload           Whether students are allowed to upload to the Asset Library directly
   * @property  {String}      name                    The name of the course
   * @property  {String}      assetlibrary_url        The URL where the asset library in this course can be reached
   * @property  {String}      whiteboards_url         The URL where the whiteboards in this course can be reached
   * @property  {Boolean}     active                  Whether this course's data should be synced with Canvas
   */
  var Course = module.exports.Course = sequelize.define('course', {
    'canvas_course_id': {
      'type': Sequelize.INTEGER,
      'allowNull': false
    },
    'enable_upload': {
      'type': Sequelize.BOOLEAN,
      'allowNull': false,
      'defaultValue': true
    },
    'name': {
      'type': Sequelize.STRING,
      'allowNull': true
    },
    'assetlibrary_url': {
      'type': Sequelize.STRING,
      'allowNull': true
    },
    'whiteboards_url': {
      'type': Sequelize.STRING,
      'allowNull': true
    },
    'active': {
      'type': Sequelize.BOOLEAN,
      'allowNull': false,
      'defaultValue': true
    }
  }, {
    'underscored': true
  });

  // Each course belongs to a specific Canvas instance
  Course.belongsTo(Canvas, {
    'onDelete': 'CASCADE',
    'as': 'canvas',
    'foreignKey': {
      'name': 'canvas_api_domain',
      'allowNull': false
    }
  });

  /**
   * The `user` table keeps track of each user that is enrolled in a course. This means that
   * the same physical student might end up with two student records within Collabosphere. As
   * there's no overlap between courses, this is acceptable.
   *
   * @property  {Number}      canvas_user_id          The id of the user in Canvas
   * @property  {String}      canvas_course_role      The role of the user in the course
   * @property  {String}      canvas_full_name        The full name of the student
   * @property  {String}      [canvas_image]          The URL that points to a profile picture for the user
   * @property  {String}      [canvas_email]          The email of the student
   * @property  {Number}      points                  The total Engagement Index points that the user has accumulated in the course
   * @property  {Boolean}     share_points            Whether the user wants to share their point total with the other students in the course
   * @property  {String}      bookmarklet_token       The bookmarklet access token for the user
   */
  var User = module.exports.User = sequelize.define('user', {
    'canvas_user_id': {
      'type': Sequelize.INTEGER,
      'allowNull': false
    },
    'canvas_course_role': {
      'type': Sequelize.STRING,
      'allowNull': false
    },
    'canvas_enrollment_state': {
      'type': Sequelize.ENUM(_.values(CollabosphereConstants.ENROLLMENT_STATE)),
      'allowNull': false
    },
    'canvas_full_name': {
      'type': Sequelize.STRING,
      'allowNull': false
    },
    'canvas_image': {
      'type': Sequelize.STRING,
      'allowNull': true
    },
    'canvas_email': {
      'type': Sequelize.STRING,
      'allowNull': true
    },
    'points': {
      'type': Sequelize.INTEGER,
      'allowNull': false,
      'defaultValue': 0
    },
    'share_points': {
      'type': Sequelize.BOOLEAN,
      'allowNull': true,
      'defaultValue': null
    },
    'last_activity': {
      'type': Sequelize.DATE,
      'allowNull': true
    },
    'bookmarklet_token': {
      'type': Sequelize.STRING(32),
      'allowNull': false
    }
  }, {
    'underscored': true,
    'getterMethods': {
      'is_admin': function() {
        if (this.canvas_course_role) {
          var userRoles = this.canvas_course_role.split(',');
          var allAdminRoles = _.union(CollabosphereConstants.ADMIN_ROLES, CollabosphereConstants.TEACHER_ROLES);
          return (_.intersection(allAdminRoles, userRoles).length > 0);
        }
      }
    },
    'instanceMethods': {
      'toJSON': function() {
        var user = _.clone(this.dataValues);
        user.is_admin = this.is_admin;
        delete user.asset_users;
        return user;
      }
    }
  });

  // Each user belongs to a specific course
  User.belongsTo(Course, {
    'onDelete': 'CASCADE',
    'foreignKey': {
      'name': 'course_id',
      'allowNull': false
    }
  });

  /**
   * The `asset` table will keep track of each asset that needs to be displayed in the asset library
   *
   * @property {String}       type                    The type of asset
   * @property {String}       title                   The title of the asset
   * @property {Number}       [canvas_assignment_id]  The id of the assignment if the asset was submitted as part of an assignment in canvas
   * @property {String}       [description]           The description of the asset
   * @property {String}       [thumbnail_url]         The thumbnail url of the asset
   * @property {String}       [image_url]             The large url of the asset
   * @property {String}       [pdf_url]               The PDF url of the asset
   * @property {Object}       [preview_metadata]      The preview metadata
   * @property {String}       [url]                   The url of the asset
   * @property {String}       [source]                The source of the asset
   * @property {String}       [body]                  The body of the asset
   * @property {Number}       likes                   The number of likes on the asset
   * @property {Number}       dislikes                The number of of dislikes on the asset
   * @property {Number}       views                   The number of times the asset has been viewed
   * @property {Number}       comment_count           The number of comments on the asset
   */
  var Asset = module.exports.Asset = sequelize.define('asset', {
    'type': {
      'type': Sequelize.ENUM(CollabosphereConstants.ASSET.ASSET_TYPES),
      'allowNull': false
    },
    'url': {
      'type': Sequelize.STRING,
      'allowNull': true
    },
    'download_url': {
      'type': Sequelize.STRING,
      'allowNull': true
    },
    'title': {
      'type': Sequelize.STRING,
      'allowNull': true
    },
    'canvas_assignment_id': {
      'type': Sequelize.INTEGER,
      'allowNull': true
    },
    'description': {
      'type': Sequelize.TEXT,
      'allowNull': true
    },
    'preview_status': {
      'type': Sequelize.STRING,
      'allowNull': false,
      'defaultValue': 'pending'
    },
    'thumbnail_url': {
      'type': Sequelize.STRING,
      'allowNull': true
    },
    'image_url': {
      'type': Sequelize.STRING,
      'allowNull': true
    },
    'pdf_url': {
      'type': Sequelize.STRING,
      'allowNull': true
    },
    'preview_metadata': {
      'type': Sequelize.JSON,
      'allowNull': false,
      'defaultValue': '{}'
    },
    'mime': {
      'type': Sequelize.STRING,
      'allowNull': true
    },
    'source': {
      'type': Sequelize.STRING,
      'allowNull': true
    },
    'body': {
      'type': Sequelize.TEXT,
      'allowNull': true
    },
    'likes': {
      'type': Sequelize.INTEGER,
      'defaultValue': 0
    },
    'dislikes': {
      'type': Sequelize.INTEGER,
      'defaultValue': 0
    },
    'views': {
      'type': Sequelize.INTEGER,
      'defaultValue': 0
    },
    'comment_count': {
      'type': Sequelize.INTEGER,
      'defaultValue': 0
    }
  }, {
    'timestamps': true,
    'paranoid': true,
    'underscored': true,
    'instanceMethods': {
      'toJSON': function() {
        var asset = _.clone(this.dataValues);

        // Add the liked status
        asset.liked = null;
        if (!_.isEmpty(asset.activities)) {
          asset.liked = asset.activities[0].type === 'like' ? true : false;
        }
        delete asset.activities;

        // Order the asset's categories by title
        if (!_.isEmpty(asset.categories)) {
          asset.categories = _.sortBy(asset.categories, 'title');
        }

        delete asset.asset_users;

        return asset;
      }
    }
  });

  // Each asset belongs to a specific course
  Asset.belongsTo(Course, {
    'onDelete': 'CASCADE',
    'foreignKey': {
      'name': 'course_id',
      'allowNull': false
    }
  });

  // An asset can belong to multiple users
  // e.g., exported whiteboards have multiple collaborators
  Asset.belongsToMany(User, {'as': 'users', 'through': 'asset_users'});
  User.belongsToMany(Asset, {'as': 'assets', 'through': 'asset_users'});

  /**
   * The `asset_whiteboard_elements` table will keep track of the whiteboard elements for each exported asset whiteboard in the asset library
   *
   * @property  {Number}      uid                     The unique whiteboard element id
   * @property  {Object}      element                 The serialized whiteboard element
   */
  var AssetWhiteboardElement = module.exports.AssetWhiteboardElement = sequelize.define('asset_whiteboard_elements', {
    'uid': {
      'type': Sequelize.TEXT,
      'primaryKey': true,
      'allowNull': false
    },
    'element': {
      'type': Sequelize.JSON,
      'allowNull': false
    }
  }, {
    'underscored': true
  });

  // Each asset whiteboard element belongs to a specific asset
  AssetWhiteboardElement.belongsTo(Asset, {
    'onDelete': 'CASCADE',
    'foreignKey': {
      'name': 'asset_id',
      'primaryKey': true,
      'allowNull': false
    },
    'as': 'whiteboard_asset'
  });

  // If an asset whiteboard element was itself added from the asset library, it may reference the original asset
  AssetWhiteboardElement.belongsTo(Asset, {
    'onDelete': 'CASCADE',
    'foreignKey': {
      'name': 'element_asset_id',
      'allowNull': true
    },
    'as': 'element_asset'
  });

  // An asset whiteboard can have multiple asset whiteboard elements. Note that this differs from the WhiteboardElement
  // relation, which tracks asset usage in whiteboards that have not themselves been exported as assets
  Asset.hasMany(AssetWhiteboardElement, {
    'as': 'whiteboard_elements',
    'foreignKey': 'asset_id'
  });

  // An asset may be associated with exported whiteboard assets in which it is included
  Asset.belongsToMany(Asset, {
    'as': 'exported_whiteboards',
    'through': 'asset_whiteboard_elements',
    'foreignKey': 'element_asset_id',
    'otherKey': 'asset_id'
  });

  /**
   * The `comment` table keeps track of comments that were made on assets
   *
   * @property  {String}      body                    The body of the comment
   */
  var Comment = module.exports.Comment = sequelize.define('comment', {
    'body': {
      'type': Sequelize.TEXT,
      'allowNull': false
    }
  }, {
    'underscored': true
  });

  // Each comment is made on an asset
  Comment.belongsTo(Asset, {
    'onDelete': 'CASCADE',
    'foreignKey': {
      'name': 'asset_id',
      'allowNull': false
    }
  });

  // Each comment is made by a user. We do not remove comments if a user is removed from the system
  Comment.belongsTo(User);

  // A comment can have a parent, technically this could allow for multi-level nesting
  // but we will only use this for 1-level nesting
  Comment.belongsTo(Comment, {
    'foreignKey': {
      'name': 'parent_id',
      'allowNull': true
    },
    'as': 'parent'
  });

  // An asset can have multiple comments
  Asset.hasMany(Comment);

  /**
   * The `category` table keeps track of which categories assets can be tagged with
   *
   * @property {String}       title                       The name of the category
   * @property {Number}       [canvas_assignment_id]      The id of the assignment to which this category is linked
   * @property {String}       [canvas_assignment_name]    The name of the assignment to which this category is linked
   */
  var Category = module.exports.Category = sequelize.define('category', {
    'title': {
      'type': Sequelize.STRING,
      'allowNull': false
    },
    'canvas_assignment_id': {
      'type': Sequelize.INTEGER,
      'allowNull': true
    },
    'canvas_assignment_name': {
      'type': Sequelize.STRING,
      'allowNull': true
    }
  }, {
    'timestamps': true,
    'paranoid': true,
    'underscored': true
  });

  // A course can have multiple categories
  Course.hasMany(Category);

  // An asset can have multiple categories
  Category.belongsToMany(Asset, {'through': 'assets_categories', 'onDelete': 'CASCADE'});
  Asset.belongsToMany(Category, {'through': 'assets_categories', 'onDelete': 'CASCADE'});

  /**
   * The `whiteboards` table will keep track of the available whiteboards in the Whiteboard tool
   *
   * @property {String}       title                   The title of the whiteboard
   * @property {String}       [thumbnail_url]         The thumbnail url of the whiteboard
   * @property {String}       [image_url]             The large url of the whiteboard
   */
  var Whiteboard = module.exports.Whiteboard = sequelize.define('whiteboard', {
    'title': {
      'type': Sequelize.STRING,
      'allowNull': true
    },
    'thumbnail_url': {
      'type': Sequelize.STRING,
      'allowNull': true
    },
    'image_url': {
      'type': Sequelize.STRING,
      'allowNull': true
    }
  }, {
    'underscored': true
  });

  // Each whiteboard belongs to a specific course
  Whiteboard.belongsTo(Course, {
    'onDelete': 'CASCADE',
    'foreignKey': {
      'name': 'course_id',
      'allowNull': false
    }
  });

  // A whiteboard can have multiple members
  User.belongsToMany(Whiteboard, {'through': 'whiteboard_members', 'onDelete': 'CASCADE'});
  Whiteboard.belongsToMany(User, {'through': 'whiteboard_members', 'onDelete': 'CASCADE'});

  /**
   * The `whiteboard_elements` table will keep track of the whiteboard elements for each whiteboard in the Whiteboard tool
   *
   * @property  {Number}      uid                     The unique whiteboard element id
   * @property  {Object}      element                 The serialized whiteboard element
   */
  var WhiteboardElement = module.exports.WhiteboardElement = sequelize.define('whiteboard_elements', {
    'uid': {
      'type': Sequelize.INTEGER,
      'primaryKey': true,
      'allowNull': false
    },
    'element': {
      'type': Sequelize.JSON,
      'allowNull': false
    }
  }, {
    'underscored': true
  });

  // Each whiteboard element belongs to a specific whiteboard
  WhiteboardElement.belongsTo(Whiteboard, {
    'onDelete': 'CASCADE',
    'foreignKey': {
      'name': 'whiteboard_id',
      'primaryKey': true,
      'allowNull': false
    }
  });

  // A whiteboard element can reference an asset
  WhiteboardElement.belongsTo(Asset, {
    'onDelete': 'CASCADE',
    'foreignKey': {
      'name': 'asset_id',
      'allowNull': true
    }
  });

  // A whiteboard can have multiple whiteboard elements
  Whiteboard.hasMany(WhiteboardElement, {'as': 'WhiteboardElements'});

  // An asset can be used as an element in multiple whiteboards. Note that this relation differs from the
  // AssetWhiteboardElement relation, which describes elements in whiteboards that have been exported as assets
  Asset.hasMany(WhiteboardElement, {'as': 'whiteboard_usages'});

  /**
   * The `whiteboard_sessions` table will keep track of the online users for each whiteboard in the Whiteboard tool.
   * Note that a user can have multiple whiteboard sessions for the same whiteboard when the user has the whiteboard
   * open in multiple browser windows. In this case, the socket id will be different for each browser window
   *
   * @property  {String}      socket_id               The unique socket id over which the user is connected
   */
  var WhiteboardSession = module.exports.WhiteboardSession = sequelize.define('whiteboard_sessions', {
    'socket_id': {
      'type': Sequelize.STRING,
      'allowNull': false,
      'primaryKey': true
    }
  }, {
    'underscored': true
  });

  // Each whiteboard session belongs to a specific whiteboard
  WhiteboardSession.belongsTo(Whiteboard, {
    'onDelete': 'CASCADE',
    'foreignKey': {
      'name': 'whiteboard_id',
      'allowNull': false
    }
  });
  Whiteboard.hasMany(WhiteboardSession);

  // Each whiteboard session belongs to a specific user
  WhiteboardSession.belongsTo(User, {
    'onDelete': 'CASCADE',
    'foreignKey': {
      'name': 'user_id',
      'allowNull': false
    }
  });

  /**
   * The `chat` table keeps track of chat messages that were made on whiteboards
   *
   * @property  {String}      body                    The body of the chat message
   */
  var Chat = module.exports.Chat = sequelize.define('chat', {
    'body': {
      'type': Sequelize.TEXT,
      'allowNull': false
    }
  }, {
    'underscored': true
  });

  // Each comment is made on a whiteboard
  Chat.belongsTo(Whiteboard, {
    'onDelete': 'CASCADE',
    'foreignKey': {
      'name': 'whiteboard_id',
      'allowNull': false
    }
  });

  // Each chat message is made by a user
  Chat.belongsTo(User);

  // A whiteboard can have multiple chat messages
  Whiteboard.hasMany(Chat);

  /**
   * The `activity` table will keep track of actions that users make in the system. This can
   * include things such as:
   *  - liking or disliking assets
   *  - commenting on assets
   *  - submitting an assignment
   *  - posting to a Canvas discussion
   *  - creating a whiteboard
   *  - ...
   *
   * As an activity can be related to different things, it's hard to enforce referential integrity without
   * adding lots of unused foreign keys to the table. That's why a more general approach has been taken:
   *  - `object_id` will be an identifier (e.g., canvas assignment id)
   *  - `object_type` will hold information about the type the id points to (e.g., a canvas assignment)
   *
   * Additional data (e.g., attachment ids for a canvas assignment) can be stored in the  `metadata`
   * property.
   *
   * @property  {String}      type                    The type of the activity
   * @property  {Number}      object_id               The id of the object on which the activity is taking place (e.g., the asset id, the comment id, etc.)
   * @property  {String}      object_type             The type of the object on which the activity is taking place. One of `CollabosphereConstants.ACTIVITY.OBJECT_TYPES`
   * @property  {Object}      metadata                Additional metadata that is associated with the activity
   */
  var Activity = module.exports.Activity = sequelize.define('activity', {
    'type': {
      'type': Sequelize.ENUM(_.pluck(ActivitiesDefaults, 'type')),
      'allowNull': false
    },
    'object_id': {
      'type': Sequelize.INTEGER,
      'allowNull': true
    },
    'object_type': {
      'type': Sequelize.ENUM(_.values(CollabosphereConstants.ACTIVITY.OBJECT_TYPES)),
      'allowNull': false
    },
    'metadata': {
      'type': Sequelize.JSON,
      'allowNull': true
    }
  }, {
    'underscored': true
  });

  // An activity can be associated to an asset
  Activity.belongsTo(Asset, {
    'onDelete': 'CASCADE',
    'foreignKey': {
      'name': 'asset_id',
      'allowNull': true
    }
  });
  Asset.hasMany(Activity);

  // Each activity happens within a course
  Activity.belongsTo(Course, {
    'onDelete': 'CASCADE',
    'foreignKey': {
      'name': 'course_id',
      'allowNull': false
    }
  });

  // The user earning the activity points
  Activity.belongsTo(User, {
    'onDelete': 'CASCADE',
    'foreignKey': {
      'name': 'user_id',
      'allowNull': false
    }
  });

  // The actor is the user that triggered the activity when different than the user earning the activity
  // points. For example, when John replies to a comment from Bella, two separate records will be created as
  // both John and Bella will be earning activity points. The first one will have John as the user without
  // an actor, as John is already the user performing the activity. The second one will have Bella as the
  // user, earning points for receiving a reply, and John as the actor as the person who created the comment.
  // When users drop out of a course, they will be removed from Collabosphere. However, the users that
  // received points through likes and comments from these users should not lose points in the Engagement
  // Index. Therefore, the actor ids will be set to null when such a user is removed from Collabosphere
  Activity.belongsTo(User, {'as': 'actor', 'onDelete': 'SET NULL'});

  /**
   * The `activity_type` table will keep track of the different activities that can occur
   * and the weights that are associated with them.
   *
   * @property  {String}      type                    The activity type. One of the types in `col-activities/lib/constants.js`
   * @property  {Number}      points                  The number of points this activity type contributes towards a user's points
   * @property  {Boolean}     enabled                 Whether activities of this type should contributed towards a user's points
   */
  var ActivityType = module.exports.ActivityType = sequelize.define('activity_type', {
    'type': {
      'type': Sequelize.ENUM(_.pluck(ActivitiesDefaults, 'type')),
      'allowNull': false
    },
    'points': {
      'type': Sequelize.INTEGER,
      'allowNull': true
    },
    'enabled': {
      'type': Sequelize.BOOLEAN,
      'defaultValue': true,
      'allowNull': true
    },
    'course_id': {
      'type': Sequelize.INTEGER,
      'allowNull': false,
      'references': {
        'model': Course,
        'key': 'id'
      }
    }
  }, {
    'underscored': true,
    'indexes': [{
      'unique': true,
      'fields': ['type', 'course_id']
    }]
  });

  // Each activity type belongs to a specific course
  ActivityType.belongsTo(Course, {
    'onDelete': 'CASCADE',
    'foreignKey': {
      'name': 'course_id',
      'primaryKey': true,
      'allowNull': false
    }
  });
};
