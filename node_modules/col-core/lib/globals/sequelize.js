/**
 * Copyright 2015 UC Berkeley (UCB) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var Promise = require('sequelize/lib/promise');

/*!
 * If an unhandled error is thrown inside the promise, we should promote it. This is needed because
 * if an unhandled exception occurs in the `callback` during the `then` handler it is considered a
 * rejection. Since we want things like unit tests to catch these in the test domain, or express to
 * catch exceptions in the error handling middlewhere, we will promote them
 */
Promise.onPossiblyUnhandledRejection(function(err) {
  throw err;
});

/**
 * Add a style helper to the sequelize Promise that allows us to use callback-style error handling
 *
 * @param  {Function}   callback        Standard callback function
 * @param  {Object}     callback.err    An error that occurred, if any
 * @param  {Args}       callback.arg0   A variable number of callback-specific return arguments
 */
Promise.prototype.complete = function(callback) {
  var called = false;
  this

    // Failure condition. This must be registered before the `then` condition to ensure that an
    // error in the callback does not get caught by this handler, risking that the callback be
    // invoked twice
    .catch(function(err) {
      if (!called) {
        called = true;

        // Send the err argument to the consumer as the first and only parameter
        callback.call(null, err);
      }
    })

    // Success condition
    .then(function() {
      if (!called) {
        called = true;

        // Shift a null value as the first parameter in the callback to indicate the result is
        // a success
        var args = Array.prototype.slice.call(arguments);
        args.unshift(null);
        callback.apply(null, args);
      }
    });
};
