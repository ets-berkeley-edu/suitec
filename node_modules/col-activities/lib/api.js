/**
 * Copyright 2015 UC Berkeley (UCB) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('lodash');
var async = require('async');
var csv = require('fast-csv');
var Joi = require('joi');
var Sequelize = require('sequelize');

var CollabosphereConstants = require('col-core/lib/constants');
var DB = require('col-core/lib/db');
var log = require('col-core/lib/logger')('col-activities');
var UserConstants = require('col-users/lib/constants');

var ActivitiesDefaults = require('./default');

/* Activities */

/**
 * Get the activities for a course that contributed points to the engagement index
 *
 * @param  {Context}            ctx                               Standard context containing the current user and the current course
 * @param  {String|String[]}    [type]                            The activity type(s) to retrieve. One of `ActivitiesDefaults`
 * @param  {Number}             [objectId]                        The id of the object on which the activity is taking place (e.g., the asset id, the comment id, etc.)
 * @param  {String}             [objectType]                      The type of the object on which the activity is taking place. One of `CollabosphereConstants.ACTIVITY.OBJECT_TYPES`
 * @param  {Function}           callback                          Standard callback function
 * @param  {Object}             callback.err                      An error that occurred, if any
 * @param  {Activity[]}         callback.activities               The activities for the course
 */
var getActivities = module.exports.getActivities = function(ctx, type, objectId, objectType, callback) {
  var options = {
    'where': {
      'course_id': ctx.course.id
    },
    'include': {
      'model': DB.User,
      'attributes': UserConstants.BASIC_USER_FIELDS
    },
    'order': 'id ASC'
  };
  if (type) {
    options.where.type = type;
  }
  if (objectId) {
    options.where.object_id = objectId;
  }
  if (objectType) {
    options.where.object_type = objectType;
  }
  DB.Activity.findAll(options).complete(function(err, activities) {
    if (err) {
      log.error({'err': err, 'options': options}, 'Failed to get the activities');
      return callback(err);
    }

    return callback(null, activities);
  });
};

/**
 * Export the activities for a course as a CSV file.
 *
 * The activities will be sorted by activity date. Each activity will also include a running total
 * of points for the user that was involved in that activity (including points for the current activity)
 *
 * @param  {Context}          ctx                               Standard context containing the current user and the current course
 * @param  {Function}         callback                          Standard callback function
 * @param  {Object}           callback.err                      An error that occurred, if any
 * @param  {String}           callback.activities               A CSV export of the activities for the course
 */
var exportActivities = module.exports.exportActivities = function(ctx, callback) {
  // Only instructors are able to get the activities for a course
  if (!ctx.user.is_admin) {
    log.error({'id': ctx.user.id}, 'Unauthorized to get the activities');
    return callback({'code': 401, 'msg': 'Unauthorized to get the activities'});
  }

  // Get the activity type configuration for the course
  getActivityTypeConfiguration(ctx.course.id, function(err, configuration) {
    if (err) {
      return callback(err);
    }

    // Get the activities for the course
    getActivities(ctx, null, null, null, function(err, activities) {
      if (err) {
        return callback(err);
      }

      // Format the activities into a CSV file
      var formattedActivities = [];
      var totalScores = {};
      _.each(activities, function(activity) {
        var formattedActivity = {
          'user_id': activity.user_id,
          'user_name': activity.user.canvas_full_name,
          'action': activity.type,
          'date': activity.created_at
        };
        formattedActivity.score = _.findWhere(configuration, {'type': activity.type}).points;
        // Add the running score for the user
        totalScores[activity.user_id] = (totalScores[activity.user_id] || 0) + formattedActivity.score;
        formattedActivity.running_total = totalScores[activity.user_id];
        formattedActivities.push(formattedActivity);
      });

      csv.writeToString(formattedActivities, {'headers': true}, callback);
    });
  });
};

/**
 * Create an activity that contributes points to the engagement index
 *
 * @param  {Course}           course                              The course to which the activity should be associated
 * @param  {User}             user                                The user earning activity points for the activity
 * @param  {String}           type                                The type of the activity. One of the types in `col-activities/lib/constants.js`
 * @param  {Number}           objectId                            The id of the object on which the activity is taking place (e.g., the asset id, the comment id, etc.)
 * @param  {String}           objectType                          The type of the object on which the activity is taking place. One of `CollabosphereConstants.ACTIVITY.OBJECT_TYPES`
 * @param  {Object}           [metadata]                          Additional metadata that is associated with the activity. For example, when creating a submission activity it might be useful to store the submission id, the attempt number and the attachment ids
 * @param  {User}             [actor]                             The user performing the activity when different than the user earning activity points
 * @param  {Function}         callback                            Standard callback function
 * @param  {Object}           callback.err                        An error that occurred, if any
 * @param  {Activity}         callback.activity                   The created activity
 */
var createActivity = module.exports.createActivity = function(course, user, type, objectId, objectType, metadata, actor, callback) {
  metadata = metadata || {};

  // Parameter validation
  var validationSchema = Joi.object().keys({
    'type': Joi.any().valid(_.pluck(ActivitiesDefaults, 'type')).required(),
    'objectId': Joi.number().required(),
    'objectType': Joi.any().valid(_.values(CollabosphereConstants.ACTIVITY.OBJECT_TYPES)).required(),
    'metadata': Joi.object().optional()
  });

  var validationResult = Joi.validate({
    'type': type,
    'objectId': objectId,
    'objectType': objectType,
    'metadata': metadata
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Create the activity in the DB
  var activity = {
    'course_id': course.id,
    'user_id': user.id,
    'type': type,
    'object_type': objectType
  };
  if (metadata) {
    activity.metadata = metadata;
  }
  if (objectType === 'asset') {
    activity.asset_id = objectId;
  } else {
    activity.object_id = objectId;
  }
  if (actor) {
    activity.actor_id = actor.id;
  }

  // TODO: Wrap this in a transaction
  DB.Activity.create(activity).complete(function(err, activity) {
    if (err) {
      log.error({'err': err}, 'Failed to create a new activity');
      return callback({'code': 500, 'msg': err.message});
    }

    // Retrieve the number of points that should be earned for
    // the current activity in the current course
    getActivityTypeConfiguration(course.id, function(err, configuration) {
      if (err) {
        return callback(err);
      }

      // Update the timestamp at which the last activity took place for the user
      setUserLastActivity(user, actor, function(err) {
        if (err) {
          return callback(err);
        }

        // Get the activity configuration for this type of activity. If it's been disabled,
        // we don't have to hand out points
        var activityConfiguration = _.findWhere(configuration, {'type': type});
        if (!activityConfiguration.enabled) {
          return callback(null, activity);
        }

        // Increase the points of the user
        var points = activityConfiguration.points;
        user.increment('points', {'by': points}).complete(function(err) {
          if (err) {
            log.error({'err': err}, 'Failed to increment the points for a user');
            return callback({'code': 500, 'msg': err.message});
          }

          return callback(null, activity);
        });
      });
    });
  });
};

/**
 * If the passed in user is the user triggering the activity, update the timestamp
 * at which the last activity took place for that user
 *
 * @param {User}            user                The user for whom to update the timestamp at which the last activity took place
 * @param {User}            [actor]             The user who triggered the activity
 * @param {Function}        callback            Standard callback function
 * @param {Object}          callback.err        An error that occurred, if any
 */
var setUserLastActivity = function(user, actor, callback) {
  if (!actor) {
    user.update({'last_activity': new Date()}).complete(function(err) {
      if (err) {
        log.error({'err': err}, 'Failed to set the last activity timestamp for a user');
        return callback({'code': 500, 'msg': err.message});
      }

      return callback();
    });
  } else {
    return callback();
  }
};

/**
 * Update an activity
 *
 * @param  {Activity}       activity            The activity to update
 * @param  {Object}         update              The updates to persist
 * @param  {Object}         [update.metadata]   The updated metadata object
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 */
var updateActivity = module.exports.updateActivity = function(activity, update, callback) {
  // Parameter validation
  var validationSchema = Joi.object().keys({
    'activity': Joi.object().type(Sequelize.Instance, 'Activity'),
    'update': Joi.object().min(1).keys({
      'metadata': Joi.object().optional()
    })
  });

  var validationResult = Joi.validate({
    'activity': activity,
    'update': update
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  activity.updateAttributes(update).complete(function(err, activity) {
    if (err) {
      log.error({'err': err, 'activity': activity.id}, 'Failed to update an activity');
      return callback({'code': 500, 'msg': 'Failed to update an activity'});
    }

    return callback(null, activity);
  });
};

/**
 * Remove an activity and undo the points it contributed to the engagement index
 *
 * @param  {Course}           course                              The course to which the activity to remove is associated
 * @param  {User}             user                                The user that earned activity points for the activity to remove
 * @param  {String|String[]}  type                                The type of the activity to remove. One of the types in `col-activities/lib/constants.js`
 * @param  {Number}           objectId                            The id of the object on which the activity took place (e.g., the asset id, the comment id, etc.)
 * @param  {String}           objectType                          The type of the object on which the activity took place. One of `CollabosphereConstants.ACTIVITY.OBJECT_TYPES`
 * @param  {User}             [actor]                             The user that performed the activity when different than the user earning activity points
 * @param  {Function}         callback                            Standard callback function
 * @param  {Object}           callback.err                        An error that occurred, if any
 * @param  {Activity}         callback.activity                   The deleted activity
 */
var deleteActivity = module.exports.deleteActivity = function(course, user, type, objectId, objectType, actor, callback) {
  // Verify if the user has already performed the activity
  var options = {
    'where': {
      'course_id': course.id,
      'user_id': user.id,
      'type': type,
      'object_type': objectType
    }
  };
  if (objectType === 'asset') {
    options.where.asset_id = objectId;
  } else {
    options.where.object_id = objectId;
  }
  if (actor) {
    options.where.actor_id = actor.id;
  }
  DB.Activity.find(options).complete(function(err, activity) {
    if (err) {
      log.error({'err': err}, 'Failed to retrieve the previous activity');
      return callback({'code': 500, 'msg': err.message});
    }

    // Return immediately if no activity has been provided
    if (!activity) {
      log.warn({
        'course': course.id,
        'user': user.id,
        'type': type,
        'objectId': objectId,
        'objectType': objectType
      }, 'Tried to delete an activity that could not be found');
      return callback();
    }

    // Retrieve the number of points that should be deducted to undo the provided activity
    getActivityTypeConfiguration(activity.course_id, function(err, configuration) {
      if (err) {
        return callback(err);
      }

      // Decrease the points of the user
      // TODO: Wrap this in a transaction
      var points = _.findWhere(configuration, {'type': activity.type}).points;
      user.decrement('points', {'by': points}).complete(function(err) {
        if (err) {
          log.error({'err': err}, 'Failed to decrement the points for a user');
          return callback({'code': 500, 'msg': err.message});
        }

        // Remove the activity
        var activityToDelete = activity.toJSON();
        activity.destroy().complete(function(err) {
          if (err) {
            log.error({'err': err, 'activity': activity}, 'Failed to delete an activity');
            return callback({'code': 500, 'msg': err.message});
          }

          return callback(null, activityToDelete);
        });
      });
    });
  });
};

/**
 * Recalculate the points for a set of users in a course. This will go through the persisted
 * activities and calculate an accurate total for each user. If no activities could be found
 * for a user, their total will be reset to 0
 *
 * @param  {Course}         course              The course for which the user points should be recalculated
 * @param  {Number[]}       [userIds]           The ids of the users to recalculate the points for. Defaults to all the users in the course
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 */
var recalculatePoints = module.exports.recalculatePoints = function(course, userIds, callback) {
  // Get the points configuration for this course
  getActivityTypeConfiguration(course.id, function(err, configuration) {
    if (err) {
      return callback(err);
    }

    // Get all the activities for the given set of users
    var options = {
      'where': {
        'course_id': course.id
      }
    };
    if (userIds) {
      options.where.user_id = userIds;
    }
    DB.Activity.findAll(options).complete(function(err, activities) {
      if (err) {
        log.error({'err': err}, 'Failed to get the activities for a set of users');
        return callback({'code': 500, 'msg': err.message});
      }

      // Index the activity configurations by type so we can more easily access them when iterating
      // through the activities
      var activityConfigurationByType = _.indexBy(configuration, 'type');

      // Run through the activities and keep track of how much each user should earn
      var pointsPerUser = {};
      _.each(activities, function(activity) {
        var userId = activity.user_id;
        pointsPerUser[userId] = pointsPerUser[userId] || 0;

        if (activityConfigurationByType[activity.type].enabled) {
          var points = activityConfigurationByType[activity.type].points;
          pointsPerUser[userId] += points;
        }
      });

      // Update the user records
      async.forEachOfSeries(pointsPerUser, setUserPoints, function(err) {
        if (err) {
          log.error({
            'err': err,
            'course': course.id
          }, 'The points could only be updated for some of the users. The leaderboard might be out of sync');
        }

        return callback(err);
      });
    });
  });
};

/**
 * Set the points for a user
 *
 * @param  {Number}         points              The new points for the user
 * @param  {Number}         userId              The id of the user to set the points for
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 */
var setUserPoints = function(points, userId, callback) {
  DB.User.findById(userId).complete(function(err, user) {
    if (err) {
      log.error({'err': err, 'user': userId}, 'An error occurred when getting the user to update points for');
      return callback({'code': 500, 'msg': err.message});
    } else if (!user) {
      log.error({'user': userId}, 'Could not find the user to update points for');
      return callback({'code': 404, 'msg': 'Could not find the user to update points for'});
    }

    // Update the user's points
    user.updateAttributes({'points': points}).complete(function(err) {
      if (err) {
        log.error({'err': err, 'user': userId}, 'Could not update the points for a user');
        return callback({'code': 500, 'msg': err.message});
      }

      return callback();
    });
  });
};

/* Points configuration */

/**
 * Get the activity type configration for a course. This will consist of the default activity
 * type configuration overlayed with the activity type configuration overrides for that course
 *
 * @param  {Number}           courseId                            The id of the course for which the activity type configuration should be retrieved
 * @param  {Function}         callback                            Standard callback function
 * @param  {Object}           callback.err                        An error that occurred, if any
 * @param  {ActivityType[]}   callback.configuration              The activity type configuration for the course
 * @param  {String}           callback.configuration.type         The type of the activity type configuration. One of the types in `col-activities/lib/constants.js`
 * @param  {String}           callback.configuration.title        The display name of the activity type
 * @param  {Number}           callback.configuration.points       The number of points this activity type will contribute towards a user's points
 * @param  {Boolean}          callback.configuration.enabled      Whether activities of this type will contribute towards a user's points
 */
var getActivityTypeConfiguration = module.exports.getActivityTypeConfiguration = function(courseId, callback) {
  // Get the activity type configraton overrides from the DB
  var options = {
    'where': {
      'course_id': courseId
    }
  };

  DB.ActivityType.findAll(options).complete(function(err, activityTypeOverrides) {
    if (err) {
      log.error({'err': err, 'course': courseId}, 'Failed to get the activity type configuration overrides');
      return callback({'code': 500, 'msg': err.message});
    }

    // Overlay the overrides on top of the activity type configuration defaults
    var configuration = _.cloneDeep(ActivitiesDefaults);
    _.each(configuration, function(typeConfiguration) {
      var override = _.findWhere(activityTypeOverrides, {'type': typeConfiguration.type});
      if (override) {
        if (!_.isNull(override.points)) {
          typeConfiguration.points = override.points;
        }
        if (!_.isNull(override.enabled)) {
          typeConfiguration.enabled = override.enabled;
        }
      }
    });

    return callback(null, configuration);
  });
};

/**
 * Edit the activity type configuration for a course. The provided activity type configuration
 * overrides will override the default activity type configuration
 *
 * @param  {Context}          ctx                                 Standard context containing the current user and the current course
 * @param  {Object[]}         activityTypeUpdates                 Activity type configuration overrides that should be aplied to the activity type configuration for the course
 * @param  {String}           activityTypeUpdates.type            The type of the activity type configuration override. One of the types in `col-activities/lib/constants.js`
 * @param  {Number}           [activityTypeUpdates.points]        The number of points this activity type should contribute towards a user's points
 * @param  {Boolean}          [activityTypeUpdates.enabled]       Whether activities of this type should contributed towards a user's points
 * @param  {Function}         callback                            Standard callback function
 * @param  {Object}           callback.err                        An error that occurred, if any
 */
var editActivityTypeConfiguration = module.exports.editActivityTypeConfiguration = function(ctx, activityTypeUpdates, callback) {
  // Only instructors are able to edit the activity type configuration
  if (!ctx.user.is_admin) {
    log.error({'id': ctx.user.id}, 'Unauthorized to edit the activity type configuration');
    return callback({'code': 401, 'msg': 'Unauthorized to edit the activity type configuration'});
  }

  // Parameter validation
  var validationSchema = Joi.array().min(1).items(Joi.object().min(2).keys({
    'type': Joi.any().valid(_.pluck(ActivitiesDefaults, 'type')).required(),
    'points': Joi.number().optional(),
    'enabled': Joi.boolean().optional()
  }));
  var validationResult = Joi.validate(activityTypeUpdates, validationSchema);
  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Ensure we only return to the caller once
  var errorCallback = _.once(callback);

  // Recalculate the points for each user in the course once each activity type override
  // is persisted
  var done = _.after(activityTypeUpdates.length, function() {
    return recalculatePoints(ctx.course, null, callback);
  });

  _.each(activityTypeUpdates, function(update) {
    // Construct an override object
    var activityTypeOverride = _.pick(update, ['type', 'points', 'enabled']);
    activityTypeOverride.course_id = ctx.course.id;

    // Create or update the activity type override
    DB.ActivityType.upsert(activityTypeOverride).complete(function(err) {
      if (err) {
        log.error({'type': err}, 'Failed to edit the configuration for an activity type');
        return errorCallback({'code': 500, 'msg': err.message});
      }

      done();
    });
  });
};
