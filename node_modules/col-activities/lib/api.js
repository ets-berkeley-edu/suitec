/**
 * Copyright 2015 UC Berkeley (UCB) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('lodash');
var async = require('async');
var csv = require('fast-csv');
var Joi = require('joi');

var CollabosphereConstants = require('col-core/lib/constants');
var DB = require('col-core/lib/db');
var log = require('col-core/lib/logger')('col-activities');
var UserConstants = require('col-users/lib/constants');

var ActivitiesDefaults = require('./default');

/* Activities */

/**
 * Get the activities for a course that contributed points to the engagement index
 *
 * @param  {Context}            ctx                             Standard context containing the current user and the current course
 * @param  {String|String[]}    [type]                          The activity type(s) to retrieve. One of `ActivitiesDefaults`
 * @param  {Number}             [objectId]                      The id of the object on which the activity is taking place (e.g., the asset id, the comment id, etc.)
 * @param  {String}             [objectType]                    The type of the object on which the activity is taking place. One of `CollabosphereConstants.ACTIVITY.OBJECT_TYPES`
 * @param  {Function}           callback                        Standard callback function
 * @param  {Object}             callback.err                    An error that occurred, if any
 * @param  {Activity[]}         callback.activities             The activities for the course
 */
var getActivities = module.exports.getActivities = function(ctx, type, objectId, objectType, callback) {
  var options = {
    'where': {
      'course_id': ctx.course.id
    },
    'include': {
      'model': DB.User,
      'attributes': UserConstants.BASIC_USER_FIELDS
    },
    'order': 'created_at ASC'
  };
  if (type) {
    options.where.type = type;
  }
  if (objectId) {
    options.where.object_id = objectId;
  }
  if (objectType) {
    options.where.object_type = objectType;
  }
  DB.Activity.findAll(options).complete(function(err, activities) {
    if (err) {
      log.error({'err': err, 'options': options}, 'Failed to get the activities');
      return callback(err);
    }

    return callback(null, activities);
  });
};

/**
 * Export the activities for a course as a CSV file
 *
 * @param  {Context}          ctx                             Standard context containing the current user and the current course
 * @param  {Function}         callback                        Standard callback function
 * @param  {Object}           callback.err                    An error that occurred, if any
 * @param  {String}           callback.activities             A CSV export of the activities for the course
 */
var exportActivities = module.exports.exportActivities = function(ctx, callback) {
  // Only administrators are able to get the activities for a course
  if (!ctx.user.is_admin) {
    log.error({'id': ctx.user.id}, 'Unauthorized to get the activities');
    return callback({'code': 401, 'msg': 'Unauthorized to get the activities'});
  }

  // Get the activity type configuration for the course
  getActivityTypeConfiguration(ctx.course.id, function(err, configuration) {
    if (err) {
      return callback(err);
    }

    // Get the activities for the course
    getActivities(ctx, null, null, null, function(err, activities) {
      if (err) {
        return callback(err);
      }

      // Format the activities into a CSV file
      var formattedActivities = [];
      var totalScores = {};
      _.each(activities, function(activity) {
        var formattedActivity = {
          'user_id': activity.user_id,
          'user_name': activity.user.canvas_full_name,
          'action': activity.type,
          'date': activity.created_at
        };
        formattedActivity.score = _.findWhere(configuration, {'type': activity.type}).points;
        // Add the running score for the user
        totalScores[activity.user_id] = (totalScores[activity.user_id] || 0) + formattedActivity.score;
        formattedActivity.running_total = totalScores[activity.user_id];
        formattedActivities.push(formattedActivity);
      });

      csv.writeToString(formattedActivities, {'headers': true}, callback);
    });
  });
};

/**
 * Create an activity that contributes points to the engagement index
 *
 * @param  {Course}           course                          The course to which the activity should be associated
 * @param  {User}             user                            The user earning activity points for the activity
 * @param  {String}           type                            The type of the activity. One of the types in `col-activities/lib/constants.js`
 * @param  {Number}           objectId                        The id of the object on which the activity is taking place (e.g., the asset id, the comment id, etc.)
 * @param  {String}           objectType                      The type of the object on which the activity is taking place. One of `CollabosphereConstants.ACTIVITY.OBJECT_TYPES`
 * @param  {Object}           [metadata]                      Additional metadata that is associated with the activity
 * @param  {User}             [actor]                         The user performing the activity when different than the user earning activity points
 * @param  {Function}         callback                        Standard callback function
 * @param  {Object}           callback.err                    An error that occurred, if any
 * @param  {Activity}         callback.activity               The created activity
 */
var createActivity = module.exports.createActivity = function(course, user, type, objectId, objectType, metadata, actor, callback) {
  // Parameter validation
  var validationSchema = Joi.object().keys({
    'type': Joi.any().valid(_.pluck(ActivitiesDefaults, 'type')).required(),
    'objectId': Joi.number().required(),
    'objectType': Joi.any().valid(_.values(CollabosphereConstants.ACTIVITY.OBJECT_TYPES)).required(),
    'metadata': Joi.object().allow(null)
  });

  var validationResult = Joi.validate({
    'type': type,
    'objectId': objectId,
    'objectType': objectType,
    'metadata': metadata
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Create the activity in the DB
  var activity = {
    'course_id': course.id,
    'user_id': user.id,
    'type': type,
    'object_type': objectType
  };
  if (metadata) {
    activity.metadata = metadata;
  }
  if (objectType === 'asset') {
    activity.asset_id = objectId;
  } else {
    activity.object_id = objectId;
  }
  if (actor) {
    activity.actor_id = actor.id;
  }

  // TODO: Wrap this in a transaction
  DB.Activity.create(activity).complete(function(err, activity) {
    if (err) {
      log.error({'err': err}, 'Failed to create a new activity');
      return callback({'code': 500, 'msg': err.message});
    }

    // Retrieve the number of points that should be earned for
    // the current activity in the current course
    getActivityTypeConfiguration(course.id, function(err, configuration) {
      if (err) {
        return callback(err);
      }

      // Increase the points of the user
      var points = _.findWhere(configuration, {'type': type}).points;
      user.increment('points', {'by': points}).complete(function(err) {
        if (err) {
          log.error({'err': err}, 'Failed to increment the points for a user');
          return callback({'code': 500, 'msg': err.message});
        }

        // If the current user is the user triggering the activity, update the timestamp
        // at which the last activity took place for that user
        if (!actor) {
          user.update({'last_activity': new Date()}).complete(function(err) {
            if (err) {
              log.error({'err': err}, 'Failed to last activity timestamp for a user');
              return callback({'code': 500, 'msg': err.message});
            }

            return callback(null, activity);
          });
        } else {
          return callback(null, activity);
        }
      });
    });
  });
};

/**
 * Update an activity
 *
 * @param  {Activity}       activity            The activity to update
 * @param  {Object}         update              The updates to persist
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 */
var updateActivity = module.exports.updateActivity = function(activity, update, callback) {
  activity.updateAttributes(update).complete(function(err, activity) {
    if (err) {
      log.error({'err': err, 'activity': activity.id}, 'Failed to update an activity');
      return callback({'code': 500, 'msg': 'Failed to update an activity'});
    }

    return callback(null, activity);
  });
};

/**
 * Remove an activity and undo the points it contributed to the engagement index
 *
 * @param  {Course}           course                          The course to which the activity to remove is associated
 * @param  {User}             user                            The user that earned activity points for the activity to remove
 * @param  {String|String[]}  type                            The type of the activity to remove. One of the types in `col-activities/lib/constants.js`
 * @param  {Number}           objectId                        The id of the object on which the activity took place (e.g., the asset id, the comment id, etc.)
 * @param  {String}           objectType                      The type of the object on which the activity took place. One of `CollabosphereConstants.ACTIVITY.OBJECT_TYPES`
 * @param  {User}             [actor]                         The user that performed the activity when different than the user earning activity points
 * @param  {Function}         callback                        Standard callback function
 * @param  {Object}           callback.err                    An error that occurred, if any
 * @param  {Activity}         callback.activity               The deleted activity
 */
var deleteActivity = module.exports.deleteActivity = function(course, user, type, objectId, objectType, actor, callback) {
  // Verify if the user has already performed the activity
  var options = {
    'where': {
      'course_id': course.id,
      'user_id': user.id,
      'type': type,
      'object_type': objectType
    }
  };
  if (objectType === 'asset') {
    options.where.asset_id = objectId;
  } else {
    options.where.object_id = objectId;
  }
  if (actor) {
    options.where.actor_id = actor.id;
  }
  DB.Activity.find(options).complete(function(err, activity) {
    if (err) {
      log.error({'err': err}, 'Failed to retrieve the previous activity');
      return callback({'code': 500, 'msg': err.message});
    }

    // Return immediately if no activity has been provided
    if (!activity) {
      return callback();
    }

    // Retrieve the number of points that should be deducted to undo the provided activity
    getActivityTypeConfiguration(activity.course_id, function(err, configuration) {
      if (err) {
        return callback(err);
      }

      // Decrease the points of the user
      // TODO: Wrap this in a transaction
      var points = _.findWhere(configuration, {'type': activity.type}).points;
      user.decrement('points', {'by': points}).complete(function(err) {
        if (err) {
          log.error({'err': err}, 'Failed to decrement the points for a user');
          return callback({'code': 500, 'msg': err.message});
        }

        // Remove the activity
        var activityToDelete = activity.toJSON();
        activity.destroy().complete(function(err) {
          if (err) {
            log.error({'err': err, 'activity': activity}, 'Failed to delete an activity');
            return callback({'code': 500, 'msg': err.message});
          }

          return callback(null, activityToDelete);
        });
      });
    });
  });
};

/**
 * Recalculate the points for a set of users in a course. This will go through the persisted
 * activities and calculate an accurate total for each user. If no activities could be found
 * for a user, their total will be reset to 0
 *
 * @param  {Course}         course              The course for which the users their points should be recalculated
 * @param  {Number[]}       userIds             The ids of the users to recalculate the points for
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 */
var recalculatePoints = module.exports.recalculatePoints = function(course, userIds, callback) {
  // Get the points configuration for this course
  getActivityTypeConfiguration(course.id, function(err, configuration) {
    if (err) {
      return callback(err);
    }

    // Get all the activities for the given set of users
    DB.Activity.findAll({
      'where': {
        'user_id': userIds
      }
    }).complete(function(err, activities) {
      if (err) {
        log.error({'err': err}, 'Failed to get the activities for a set of users');
        return callback({'code': 500, 'msg': err.message});
      }

      // Default each of the given users to 0
      var pointsPerUser = {};
      _.each(userIds, function(userId) {
        pointsPerUser[userId] = 0;
      });

      // Run through the activities and keep track of how much each user should earn
      _.each(activities, function(activity) {
        var points = _.findWhere(configuration, {'type': activity.type}).points;
        pointsPerUser[activity.user_id] += points;
      });

      // Update the user records
      async.eachSeries(_.pairs(pointsPerUser), setUserPoints, callback);
    });
  });
};

/**
 * Set the points for a user
 *
 * @param  {Number[]}       userPoints          Maps the points to a user id. The first value should be the id of the user to set the points for, the second should be the points
 * @param  {Function}       callback            Standard callback function
 * @param  {Object}         callback.err        An error that occurred, if any
 */
var setUserPoints = function(userPoints, callback) {
  var userId = userPoints[0];
  var points = userPoints[1];

  DB.User.findById(userId).complete(function(err, user) {
    if (err) {
      log.error({'err': err, 'user': userId}, 'Could not find a user to update points for');
      return callback({'code': 500, 'msg': err.message});
    }

    // Update the user's points
    user.updateAttributes({'points': points}).complete(callback);
  });
};

/* Points configuration */

/**
 * Get the activity type configration for a course. This will consist of the default activity
 * type configuration overlayed with the activity type configuration overrides for that course
 *
 * @param  {Number}           courseId                        The id of the course for which the activity type configuration should be retrieved
 * @param  {Function}         callback                        Standard callback function
 * @param  {Object}           callback.err                    An error that occurred, if any
 * @param  {ActivityType[]}   callback.configuration          The activity type configuration for the course
 */
var getActivityTypeConfiguration = module.exports.getActivityTypeConfiguration = function(courseId, callback) {
  // Get the activity type configraton overrides from the DB
  var options = {
    'where': {
      'course_id': courseId
    }
  };

  DB.ActivityType.findAll(options).complete(function(err, activityTypeOverrides) {
    if (err) {
      log.error({'err': err, 'course': courseId}, 'Failed to get the activity type configuration overrides');
      return callback({'code': 500, 'msg': err.message});
    }

    // Overlay the overrides on top of the activity type configuration defaults
    var configuration = _.cloneDeep(ActivitiesDefaults);
    _.each(configuration, function(typeConfiguration) {
      var override = _.findWhere(activityTypeOverrides, {'type': typeConfiguration.type});
      if (override) {
        if (!_.isNull(override.points)) {
          typeConfiguration.points = override.points;
        }
        if (!_.isNull(override.enabled)) {
          typeConfiguration.enabled = override.enabled;
        }
      }
    });

    return callback(null, configuration);
  });
};

/**
 * Edit the configuration for an activity type in a course. This will override the
 * default configuration for that activity type
 *
 * @param  {Context}          ctx                             Standard context containing the current user and the current course
 * @param  {String}           type                            The activity type for which the configuration should be updated. One of the types in `col-activities/lib/constants.js`
 * @param  {Number}           [points]                        The number of points this activity type should contribute towards a user's points
 * @param  {Boolean}          [enabled]                       Whether activities of this type should contributed towards a user's points
 * @param  {Function}         callback                        Standard callback function
 * @param  {Object}           callback.err                    An error that occurred, if any
 */
var editActivityTypeConfiguration = module.exports.editActivityTypeConfiguration = function(ctx, type, points, enabled, callback) {
  // Only administrators are able to edit the configuration for an activity type
  if (!ctx.user.is_admin) {
    log.error({'id': ctx.user.id}, 'Unauthorized to edit the configuration for an activity type');
    return callback({'code': 401, 'msg': 'Unauthorized to edit the configuration for an activity type'});
  }

  // Parameter validation
  var validationSchema = Joi.object().keys({
    'type': Joi.any().valid(_.pluck(ActivitiesDefaults, 'type')).required(),
    'points': Joi.number().optional(),
    'enabled': Joi.boolean().optional()
  });

  var validationResult = Joi.validate({
    'type': type,
    'points': points,
    'enabled': enabled
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  } else if (!_.isFinite(points) && !_.isBoolean(enabled)) {
    return callback({'code': 400, 'msg': 'Either a points value or an enabled value needs to be provided'});
  }

  // Store the activity type configuration override in the DB.
  // If an activity type configuration already exists, it will
  // be overwritten
  var activityTypeOverride = {
    'course_id': ctx.course.id,
    'type': type,
    'points': points,
    'enabled': enabled
  };

  DB.ActivityType.upsert(activityTypeOverride).complete(function(err) {
    if (err) {
      log.error({'type': err}, 'Failed to edit the configuration for an activity type');
      return callback({'code': 500, 'msg': err.message});
    }

    // TODO: Trigger re-calculation of Engagement Index points

    return callback();
  });
};
