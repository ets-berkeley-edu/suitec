/**
 * Copyright 2015 UC Berkeley (UCB) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('lodash');
var async = require('async');

var ActivitiesAPI = require('col-activities');
var CanvasAPI = require('./api');
var CollabosphereConstants = require('col-core/lib/constants');
var DB = require('col-core/lib/db');
var log = require('col-core/lib/logger')('col-canvas/poller');
var UsersAPI = require('col-users');

var pollerIntervalId = null;

// The number of milliseconds there should be between processing two courses. This alleviates
// some of the throttling restrictions that Canvas imposes on their API
var MINIMUM_INTERVAL_BETWEEN_COURSES = 5000;

/**
 * Enable the Canvas poller
 *
 * @param  {Number}   interval    The number of seconds to wait between two consecutive polling operations
 */
var enable = module.exports.enable = function(interval) {
  log.info('Enabling Canvas poller, running every %d seconds', interval);

  // Make sure there's no other poller running
  disable();

  // Start a new poller
  pollerIntervalId = setInterval(poll, interval * 1000);
};

/**
 * Disable the currently running poller, if any
 */
var disable = module.exports.disable = function() {
  if (pollerIntervalId) {
    clearInterval(pollerIntervalId);
  }
};

/**
 * Poll the Canvas REST API synchronizing users and activities
 *
 * @api private
 */
var poll = function() {
  log.debug('Polling the Canvas REST API for all courses');
  var start = Date.now();

  getCourses(function(err, courses) {
    if (err) {
      log.error({'err': err}, 'Failed to get all the courses, aborting poller');
      return;
    }

    // Canvas enforces a strict throttling scheme  that forces us to not send more
    // than 1 request at a time. (see https://canvas.instructure.com/doc/api/file.throttling.html)
    // We achieve this by polling resources in series and using lodash's throttle function
    var throttledCourseHandling = _.throttle(handleCourse, MINIMUM_INTERVAL_BETWEEN_COURSES);
    async.eachSeries(courses, throttledCourseHandling, function(err) {
      log.info('Polling completed for %d courses, took %d ms', courses.length, (Date.now() - start));
    });
  });
};

/**
 * Get all the courses from the database
 *
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Course[]}   callback.courses        The courses in the database. The associated `Canvas` object will be retrieved as well
 * @api private
 */
var getCourses = function(callback) {
  var options = {
    'include': [{
      'model': DB.Canvas,
      'as': 'canvas'
    }]
  };
  DB.Course.findAll(options).complete(callback);
};

/**
 * Poll the Canvas REST API for a specific course. Activities will be created
 * for all new assignments, discussion topics and/or discussion entries.
 *
 * @param  {Course}     course                  The course to poll
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @api private
 */
var handleCourse = function(course, callback) {
  getAllUsers(course, function(err, users) {
    if (err) {
      log.error({'err': err, 'course': course.id}, 'Unable to get the users of a course');
      return callback(err);
    }

    pollAssignments(course, users, function(err) {
      if (err) {
        return callback(err);
      }

      return pollDiscussions(course, users, callback);
    });
  });
};

/* Users */

/**
 * Get all the users for a course
 *
 * @param  {Course}     course                  The course for which to get the users
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Object}     callback.users          The users in the course indexed by their `canvas_user_id` attribute. Only the `id` and `canvas_user_id` attributes are available
 * @api private
 */
var getAllUsers = function(course, callback) {
  // Get all the users in the Collabosphere database
  getUsersFromDatabase(course, function(err, users) {
    if (err) {
      return callback(err);
    }

    // Some students might enroll in the course later on, so we have to fetch the full set
    // of users in the course each time
    pollUsers(course, users, callback);
  });
};

/**
 * Get all the users for a course that are already in the Collabosphere database
 *
 * @param  {Course}     course                  The course for which to get the users
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Object}     callback.users          The users in the course indexed by their `canvas_user_id` attribute. Only the `id` and `canvas_user_id` attributes are available
 * @api private
 */
var getUsersFromDatabase = function(course, callback) {
  var options = {
    'where': {
      'course_id': course.id
    },
    'attributes': ['id', 'canvas_user_id']
  };
  DB.User.findAll(options).complete(function(err, users) {
    if (err) {
      log.error({'err': err}, 'Failed to retrieve the collabosphere users for a course');
      return callback({'code': 500, 'msg': 'Failed to retrieve the collabosphere users for a course'});
    }

    // Index the users by their Canvas user id. This allows for quicker lookups later on
    var usersByCanvasUserId = _.indexBy(users, 'canvas_user_id');
    return callback(null, usersByCanvasUserId);
  });
};

/**
 * Get all the enrolled users from the Canvas REST API and ensure there are corresponding
 * user objects in the database
 *
 * @param  {Course}     course                  The course for which to get the users
 * @param  {Object}     users                   The previously synchronized users in the course indexed by their `canvas_user_id` attribute
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @param  {Object}     callback.users          The users in the course indexed by their `canvas_user_id` attribute. Only the `id` and `canvas_user_id` attributes are available
 * @api private
 */
var pollUsers = function(course, users, callback) {
  var options = {
    'enrollment_state': [
      CollabosphereConstants.ENROLLMENT_STATE.ACTIVE,
      CollabosphereConstants.ENROLLMENT_STATE.COMPLETED
    ]
  };
  CanvasAPI.getCourseUsers(course, options, function(err, canvasUsers) {
    if (err) {
      return callback(err);
    }

    // Ensure that we have a record for each Canvas user
    var userIterator = handleUser.bind(null, course, users);
    async.eachSeries(canvasUsers, userIterator, function(err) {
      if (err) {
        return callback(err);
      }

      return callback(null, users);
    });
  });
};

/**
 * Create a user account for an enrolled user if they don't have one yet
 *
 * @param  {Course}     course                  The course in which the user is enrolled
 * @param  {Object}     users                   The users in the course indexed by their `canvas_user_id` attribute. Any new users will be auto-inserted
 * @param  {Object}     canvasUser              The Canvas user object to synchronize
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @api private
 */
var handleUser = function(course, users, canvasUser, callback) {
  // If the user is already present in the `users` set, we have synchronized them previously.
  if (users[canvasUser.id]) {
    return callback();
  }

  // Otherwise we'll need to create a user record for them
  var defaults = {
    // Unfortunately Canvas doesn't give us the role of the user. By default we assume
    // the user is a Student. If the user is not a Student, their role will be updated
    // when they launch one of the LTI tools
    'canvas_course_role': 'Student',
    'canvas_full_name': canvasUser.name
  };
  UsersAPI.getOrCreateUser(canvasUser.id, course, defaults, function(err, user) {
    if (err) {
      return callback(err);
    }

    // Add the new user into the set of synchronized course users so it can be used later on
    users[canvasUser.id] = user;
    return callback();
  });
};

/* Assignments */

/**
 * Get the assignments in a course and create activities for any submissions that were made
 *
 * @param  {Course}     course                  The course for which to poll the assignments
 * @param  {Object}     users                   The users in the course indexed by their `canvas_user_id` attribute
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @api private
 */
var pollAssignments = function(course, users, callback) {
  CanvasAPI.getAssignments(course, function(err, assignments) {
    if (err) {
      return callback(err);
    }

    // Get the submissions for the assignment
    var assignmentIterator = handleAssignment.bind(null, course, users);
    async.eachSeries(assignments, assignmentIterator, callback);
  });
};

/**
 * Handle an assignment
 *
 * @param  {Course}     course                  The course for which to handle the assignment
 * @param  {Object}     users                   The users in the course indexed by their `canvas_user_id` attribute
 * @param  {Object}     assignment              The assignment to handle
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @api private
 */
var handleAssignment = function(course, users, assignment, callback) {
  if (!assignment.has_submitted_submissions) {
    log.debug({
      'assignment': {
        'id': assignment.id,
        'name': assignment.name
      },
      'course': course.id
    }, 'Ignoring assignment as it has no submissions yet');
    return callback();
  }

  // Reduce database querying by getting all the activities
  // related to this assignment
  var objectType = CollabosphereConstants.ACTIVITY.OBJECT_TYPES.CANVAS_SUBMISSION;
  getActivities(course, users, 'submit_assignment', assignment.id, objectType, function(err, activities) {
    if (err) {
      return callback(err);
    }

    // Get all the submissions for the assignment
    CanvasAPI.getSubmissions(course, assignment, function(err, submissions) {
      if (err) {
        return callback(err);
      }

      // Handle each submission
      var submissionIterator = handleSubmission.bind(null, course, users, assignment, activities);
      async.eachSeries(submissions, submissionIterator, callback);
    });
  });
};

/**
 * Handle a submission
 *
 * @param  {Course}     course                The course for which to handle the submission
 * @param  {Object}     users                 All the users in the course, indexed by their canvas user id
 * @param  {Object}     assignment            The assignment that the submission is for
 * @param  {Object}     activities            All the activities for the assignment
 * @param  {Object}     submission            The submission to handle
 * @param  {Function}   callback              Standard callback function
 * @param  {Object}     callback.err          An error that occurred, if any
 * @api private
 */
var handleSubmission = function(course, users, assignment, activities, submission, callback) {
  var activity = {
    'type': 'submit_assignment',
    'objectId': assignment.id,
    'objectType': CollabosphereConstants.ACTIVITY.OBJECT_TYPES.CANVAS_SUBMISSION,
    'user': {
      'id': submission.user_id,
      // Unfortunately, submissions don't hold student names
      'name': 'Student ' + submission.user_id
    }
  };
  return createActivity(course, activities, users, activity, callback);
};

/* Discussions */

/**
 * Create activities for any discussion activities in the Canvas course
 *
 * @param  {Course}     course                  The course for which to poll the discussions
 * @param  {Object}     users                   The users in the course indexed by their `canvas_user_id` attribute
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @api private
 */
var pollDiscussions = function(course, users, callback) {
  CanvasAPI.getDiscussions(course, function(err, discussions) {
    if (err) {
      return callback(err);
    } else if (_.isEmpty(discussions)) {
      return callback();
    }

    // Get all the discussion activities in this course
    var types = ['discussion_topic', 'discussion_entry', 'discussion_entry_get_reply'];
    getActivities(course, users, types, null, null, function(err, activities) {
      if (err) {
        return callback(err);
      }

      // Get the comments for each discussion
      var discussionIterator = handleDiscussion.bind(null, course, activities, users);
      async.eachSeries(discussions, discussionIterator, callback);
    });
  });
};

/**
 * Create an activity for a discussion topic
 *
 * @param  {Course}     course                  The course for which to handle the discussion
 * @param  {Object}     activities              All the discussion related activities in the course
 * @param  {Object}     users                   All the users in the course indexed by their canvas user id
 * @param  {Object}     discussion              The discussion to handle
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @api private
 */
var handleDiscussion = function(course, activities, users, discussion, callback) {
  var activity = {
    'type': 'discussion_topic',
    'objectId': discussion.id,
    'objectType': CollabosphereConstants.ACTIVITY.OBJECT_TYPES.CANVAS_DISCUSSION,
    'user': {
      'id': discussion.author.id,
      'name': discussion.author.display_name
    }
  };
  createActivity(course, activities, users, activity, function(err) {
    if (err) {
      return callback(err);

    // If there are no replies, we can return early
    } else if (discussion.discussion_subentry_count === 0) {
      return callback();
    }

    // Get the entries on each discussion
    CanvasAPI.getEntries(course, discussion, function(err, entries) {
      if (err) {
        return callback(err);
      }

      var discussionEntryIterator = handleDiscussionEntry.bind(null, course, activities, users, discussion);
      async.eachSeries(entries, discussionEntryIterator, callback);
    });
  });
};

/**
 * Create an activity for a discussion entry
 *
 * @param  {Course}     course                  The course for which to handle the discussion entry
 * @param  {Object}     activities              All the discussion related activities in the course
 * @param  {Object}     users                   All the users in the course indexed by their canvas user id
 * @param  {Object}     discussion              The discussion to which the entry belongs
 * @param  {Object}     entry                   The discussion entry to handle
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @api private
 */
var handleDiscussionEntry = function(course, activities, users, discussion, entry, callback) {
  var activity = {
    'type': 'discussion_entry',
    'objectId': discussion.id,
    'objectType': CollabosphereConstants.ACTIVITY.OBJECT_TYPES.CANVAS_DISCUSSION,
    'user': {
      'id': entry.user_id,
      'name': entry.user_name
    }
  };
  createActivity(course, activities, users, activity, function(err) {
    if (err) {
      return callback(err);
    }

    // Handle the replies, if any
    entry.recent_replies = entry.recent_replies || [];
    var discussionEntryReplyIterator = handleDiscussionEntryReply.bind(null, course, activities, users, discussion, entry);
    async.eachSeries(entry.recent_replies, discussionEntryReplyIterator, callback);
  });
};

/**
 * Create an activity for a reply on a discussion entry
 *
 * @param  {Course}     course                  The course for which to handle the discussion entry
 * @param  {Object}     activities              All the discussion related activities in the course
 * @param  {Object}     users                   All the users in the course indexed by their canvas user id
 * @param  {Object}     discussion              The discussion to which the entry belongs
 * @param  {Object}     entry                   The discussion entry to which the reply was made
 * @param  {Object}     reply                   The discussion reply to handle
 * @param  {Function}   callback                Standard callback function
 * @param  {Object}     callback.err            An error that occurred, if any
 * @api private
 */
var handleDiscussionEntryReply = function(course, activities, users, discussion, entry, reply, callback) {
  // Create an activity for replying on a discussion
  var activity = {
    'type': 'discussion_entry',
    'objectId': discussion.id,
    'objectType': CollabosphereConstants.ACTIVITY.OBJECT_TYPES.CANVAS_DISCUSSION,
    'user': {
      'id': entry.user_id,
      'name': entry.user_name
    }
  };
  createActivity(course, activities, users, activity, function(err) {
    if (err) {
      return callback(err);
    }

    // Create an activity for getting a reply
    activity = {
      'type': 'discussion_entry_get_reply',
      'objectId': discussion.id,
      'objectType': CollabosphereConstants.ACTIVITY.OBJECT_TYPES.CANVAS_DISCUSSION,
      'user': {
        'id': entry.user_id,
        'name': entry.user_name
      },
      'actor': {
        'id': reply.user_id,
        'name': reply.user_name
      }
    };
    return createActivity(course, activities, users, activity, callback);
  });
};

/* Utilities */

/**
 * Get the activities matching a set of criteria
 *
 * @param  {Course}             course                      The course for which to get activities
 * @param  {Object}             users                       The users in the course indexed by their `canvas_user_id` attribute
 * @param  {String|String[]}    type                        The type(s) of activity to retrieve
 * @param  {Number}             [objectId]                  The id of the object on which the activity is taking place (e.g., the asset id, the comment id, etc.)
 * @param  {String}             [objectType]                The type of the object on which the activity is taking place. One of `CollabosphereConstants.ACTIVITY.OBJECT_TYPES`
 * @param  {Function}           callback                    Standard callback function
 * @param  {Object}             callback.err                An error that occurred, if any
 * @param  {Object}             callback.activities         The activities matching the criteria indexed by the Canvas user id, activity type and object id
 * @api private
 */
var getActivities = function(course, users, type, objectId, objectType, callback) {
  var options = {
    'where': {
      'course_id': course.id,
      'type': type
    },
    'attributes': ['type', 'user_id', 'object_id']
  };
  if (objectId) {
    options.where.object_id = objectId;
  }
  if (objectType) {
    options.where.object_type = objectType;
  }
  DB.Activity.findAll(options).complete(function(err, activities) {
    if (err) {
      log.error({'err': err, 'options': options}, 'Failed to get the activities');
      return callback(err);
    }

    // Index the users by their Collabosphere user id for easy lookup
    var usersById = _.chain(users)
      .values()
      .indexBy('id')
      .value();

    // Index the activities on their Canvas user id, activity type and object id. This allows
    // for quickly checking whether an activity has already been tracked
    var indexedActivities = {};
    _.each(activities, function(activity) {
      var canvasUserId = usersById[activity.user_id].canvas_user_id;
      indexedActivities[canvasUserId] = indexedActivities[canvasUserId] || {};
      indexedActivities[canvasUserId][activity.type] = indexedActivities[canvasUserId][activity.type] || {};
      indexedActivities[canvasUserId][activity.type][activity.object_id] = true;
    });

    return callback(null, indexedActivities);
  });
};

/**
 * Create an activity when it hasn't been tracked yet
 *
 * @param  {Course}       course                  The course in which the activity takes place
 * @param  {Object}       activities              A set of similar activities in which a lookup can be done to determine whether this activity should be created
 * @param  {Object}       users                   A mapping of canvas user ids to Collabosphere users for all the users in the course
 * @param  {Object}       activity                The activity to create
 * @param  {String}       activity.type           The type of the activity
 * @param  {Number}       activity.objectId       The id of the object on which the activity is taking place (e.g., the asset id, the comment id, etc.)
 * @param  {String}       activity.objectType     The type of the object on which the activity is taking place. One of `CollabosphereConstants.ACTIVITY.OBJECT_TYPES`
 * @param  {Object}       activity.user           The Canvas user information of the user earning activity points for the activity
 * @param  {Number}       activity.user.id        The Canvas id of the user
 * @param  {String}       activity.user.name      The name of the user in Canvas
 * @param  {Object}       activity.actor          The Canvas user information of the user performing the activity when different than the user earning activity points
 * @param  {Number}       activity.actor.id       The Canvas id of the user
 * @param  {String}       activity.actor.name     The name of the user in Canvas
 * @param  {Function}     callback                Standard callback function
 * @param  {Object}       callback.err            An error that occurred, if any
 * @api private
 */
var createActivity = function(course, activities, users, activity, callback) {
  // Don't create an activity if we've already done so
  if (hasActivity(activities, activity.user.id, activity.type, activity.objectId)) {
    return callback();
  }

  // Get the Collabosphere user objects. As we poll the list of users before checking any
  // activities, all users should be mappable from a canvas user id to a Collabosphere user object
  var user = users[activity.user.id];
  var actor = null;
  if (activity.actor) {
    actor = users[activity.actor.id];
  }

  // Create the activity
  log.info({'activity': activity}, 'Creating activity');
  return ActivitiesAPI.createActivity(course, user, activity.type, activity.objectId, activity.objectType, actor, callback);
};

/**
 * Check whether an activity can be found in a set of indexed activities
 *
 * @param  {Object}       indexedActivities       A set of activities as returned by `..`
 * @param  {Number}       canvasUserId            The Canvas id of the user who should've caused the activity
 * @param  {String}       type                    The activity type
 * @param  {String}       objectId                The id of the object on which the activity is taking place (e.g., the asset id, the comment id, etc.)
 * @return {Boolean}                              Whether or not the activity could be found in the set of indexed activities
 * @api private
 */
var hasActivity = function(indexedActivities, canvasUserId, type, objectId) {
  return (indexedActivities[canvasUserId] && indexedActivities[canvasUserId][type] && indexedActivities[canvasUserId][type][objectId]);
};
