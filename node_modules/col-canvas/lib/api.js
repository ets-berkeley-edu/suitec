/**
 * Copyright 2015 UC Berkeley (UCB) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('lodash');
var fs = require('fs');
var Joi = require('joi');
var mime = require('mime');
var path = require('path');
var request = require('request');
var util = require('util');

var DB = require('col-core/lib/db');
var log = require('col-core/lib/logger')('col-canvas');

/**
 * Get a Canvas instance by its API domain and LTI key
 *
 * @param  {String}     apiDomain             The domain on which Canvas is running
 * @param  {String}     ltiKey                The basic LTI key that will be used to embed the tools into Canvas
 * @param  {Function}   callback              Standard callback function
 * @param  {Object}     callback.err          An error object, if any
 * @param  {Canvas}     callback.canvas       The retrieved Canvas instance
 */
var getCanvas = module.exports.getCanvas = function(apiDomain, ltiKey, callback) {
  // Parameter validation
  var validationSchema = Joi.object().keys({
    'apiDomain': Joi.string().required(),
    'ltiKey': Joi.string().alphanum().length(32)
  });

  var validationResult = Joi.validate({
    'apiDomain': apiDomain,
    'ltiKey': ltiKey
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Retrieve the Canvas instance from the DB
  var options = {
    'where': {
      'canvas_api_domain': apiDomain,
      'lti_key': ltiKey
    }
  };
  DB.Canvas.findOne(options).complete(function(err, canvas) {
    if (err) {
      log.error({'err': err, 'apiDomain': apiDomain}, 'Failed to get a Canvas instance');
      return callback({'code': 500, 'msg': err.message});
    } else if (!canvas) {
      log.warn({'err': err, 'apiDomain': apiDomain}, 'A Canvas instance with the specified api domain and consumer lti key could not be found');
      return callback({'code': 404, 'msg': 'A Canvas instance with the specified api domain and consumer lti key could not be found'});
    }

    return callback(null, canvas);
  });
};

/* FILE UPLOAD */

/**
 * Upload a file to a course in Canvas
 *
 * @param  {Context}        ctx                   Standard context containing the current user and the current course
 * @param  {String}         filePath              The path of the file that should be uploaded
 * @param  {Function}       callback              Standard callback function
 * @param  {Object}         callback.err          An error that occurred, if any
 * @param  {Object}         callback.fileInfo     The metadata of the file as returned by Canvas
 */
var uploadFileToCanvas = module.exports.uploadFileToCanvas = function(ctx, filePath, callback) {
  reloadCanvasObject(ctx.course.canvas, function(err) {
    if (err) {
      return callback(err);
    }

    // Step 1: Tell Canvas that we want to upload a file. Canvas will give us some information about
    // where we should ship the file to in step 2
    notifyCanvasOfUpload(ctx, filePath, function(err, uploadInfo) {
      if (err) {
        return callback(err);
      }

      // Step 2: Upload the file to wherever Canvas wants us to upload it. In development this will
      // be your local canvas instance, in production this will probably be an Amazon S3 bucket
      uploadFile(ctx, filePath, uploadInfo, function(err, confirmUrl) {
        if (err) {
          return callback(err);
        }

        // Step 3: Confirm the file was uploaded to Canvas
        confirmFile(ctx, confirmUrl, function(err, file) {
          if (err) {
            return callback(err);
          }

          // Step 4: Hide the file so it doesn't show up in the Files Tool for students
          return hideFile(ctx, file, callback);
        });
      });
    });
  });
};

/**
 * Tell Canvas that we want to upload a file. Canvas will give us some information about where the
 * file should actually be stored.
 *
 * See step 1 at https://canvas.beta.instructure.com/doc/api/file.file_uploads.html
 *
 * @param  {Context}        ctx                   Standard context containing the current user and the current course
 * @param  {String}         filePath              The path for the file that should be uploaded
 * @param  {Function}       callback              Standard callback function
 * @param  {Object}         callback.err          An error that occurred, if any
 * @param  {Object}         callback.uploadInfo   The signed information that allows us to upload the file
 * @api private
 */
var notifyCanvasOfUpload = function(ctx, filePath, callback) {
  var url = util.format('%s/api/v1/courses/%d/files', getBaseURI(ctx.course.canvas), ctx.course.canvas_course_id);
  var fileInfo = fs.statSync(filePath);
  var contentType = mime.lookup(filePath);

  // We hash the files into folders with an hourly granularity. This avoids generating folders
  // which have to hold lots of files
  var d = new Date();
  var parentFolder = util.format('_collabosphere/%d/%d/%d/%d', d.getFullYear(), d.getMonth(), d.getDate(), d.getHours());

  // Prefix the file with an epoch timestamp. This is a crude attempt at avoiding
  // file name collisions
  var filename = util.format('%d_%d_%s', ctx.course.id, d.getTime(), path.basename(filePath));
  var opts = {
    'url': url,
    'method': 'POST',
    'headers': {
      'Authorization': util.format('Bearer %s', ctx.course.canvas.api_key)
    },
    'form': {
      // Some information about the file
      'name': filename,
      'filesize': fileInfo.size,
      'content_type': contentType,

      // The folder in which the file should be uploaded
      'parent_folder_path': parentFolder,

      // Overwrite any existing files
      'on_duplicate': 'overwrite'
    }
  };
  request(opts, function(err, response, body) {
    if (err) {
      log.error({'err': err, 'course': ctx.course.id}, 'Failed to notify Canvas of a file upload');
      return callback({'code': 500, 'msg': 'Failed to notify Canvas of a file upload'});
    } else if (response.statusCode !== 200) {
      log.error({'err': err, 'course': ctx.course.id, 'body': body}, 'Failed to notify Canvas of a file upload');
      return callback({'code': 500, 'msg': 'Failed to notify Canvas of a file upload'});
    }

    var uploadInfo = null;
    try {
      uploadInfo = JSON.parse(body);
    } catch (parseErr) {
      log.error({'err': parseErr, 'course': ctx.course.id}, 'Failed to parse Canvas response');
      return callback({'code': 500, 'msg': 'Failed to parse Canvas response'});
    }

    return callback(null, uploadInfo);
  });
};

/**
 * Upload the file to the storage back-end. This could be a Canvas instance but could just as well be
 * an Amazon S3 bucket.
 *
 * See step 2 at https://canvas.beta.instructure.com/doc/api/file.file_uploads.html
 *
 * @param  {Context}        ctx                   Standard context containing the current user and the current course
 * @param  {String}         filePath              The path of the file that should be uploaded
 * @param  {Object}         uploadInfo            The signed information that allows us to upload the file
 * @param  {Function}       callback              Standard callback function
 * @param  {Object}         callback.err          An error that occurred, if any
 * @param  {Object}         callback.fileInfo     The file information for the uploaded file as described by the Canvas API
 * @api private
 */
var uploadFile = function(ctx, filePath, uploadInfo, callback) {
  var opts = {
    'url': uploadInfo.upload_url,
    'method': 'POST',
    'headers': {
      'Authorization': util.format('Bearer %s', ctx.course.canvas.api_key)
    }
  };
  var r = request(opts, function(err, response, body) {
    if (err) {
      log.error({'err': err, 'course': ctx.course.id}, 'Failed to upload the file');
      return callback({'code': 500, 'msg': 'Failed to upload the file'});
    } else if (!(response.statusCode === 301 || response.statusCode === 302)) {
      log.error({'err': err, 'course': ctx.course.id, 'body': body}, 'Failed to upload the file');
      return callback({'code': 500, 'msg': 'Failed to upload the file'});
    }

    var confirmUrl = response.headers.location;
    return callback(null, confirmUrl);
  });

  // We need to add the parameters as multi-part blocks
  var form = r.form();

  // Append all the parameters that we retrieved earlier
  _.each(uploadInfo.upload_params, function(value, key) {
    form.append(key, value);
  });

  // Append the file. Note that the file should always be appended last
  form.append('file', fs.createReadStream(filePath));
};

/**
 * Confirm that a file has been uploaded to the appropriate file back-end
 *
 * See step 3 at https://canvas.beta.instructure.com/doc/api/file.file_uploads.html
 *
 * @param  {Context}        ctx                   Standard context containing the current user and the current course
 * @param  {String}         confirmUrl            The URL that was returned from the file back-end
 * @param  {Function}       callback              Standard callback function
 * @param  {Object}         callback.err          An error that occurred, if any
 * @param  {Object}         callback.fileInfo     The file information for the uploaded file as described by the Canvas API
 * @api private
 */
var confirmFile = function(ctx, confirmUrl, callback) {
  var opts = {
    'url': confirmUrl,
    'method': 'POST',
    'headers': {
      'Authorization': util.format('Bearer %s', ctx.course.canvas.api_key)
    }
  };
  request(opts, function(err, response, body) {
    if (err) {
      log.error({'err': err, 'course': ctx.course.id}, 'Failed to confirm the file upload');
      return callback({'code': 500, 'msg': 'Failed to confirm the file upload'});
    } else if (response.statusCode !== 200) {
      log.error({'err': err, 'course': ctx.course.id, 'body': body}, 'Failed to confirm the file upload');
      return callback({'code': 500, 'msg': 'Failed to confirm the file upload'});
    }

    var fileInfo = null;
    try {
      fileInfo = JSON.parse(body);
    } catch (parseErr) {
      log.error({'err': parseErr, 'course': ctx.course.id}, 'Failed to parse Canvas confirm response');
      return callback({'code': 500, 'msg': 'Failed to parse Canvas confirm response'});
    }

    return callback(null, fileInfo);
  });
};

/**
 * Hide a file. This will ensure that students can't see the uploaded file in the Files tool.
 *
 * @param  {Context}        ctx                   Standard context containing the current user and the current course
 * @param  {Object}         file                  The file information for the uploaded file as described by the Canvas API
 * @param  {Function}       callback              Standard callback function
 * @param  {Object}         callback.err          An error that occurred, if any
 * @api private
 */
var hideFile = function(ctx, file, callback) {
  var url = util.format('%s/api/v1/files/%d', getBaseURI(ctx.course.canvas), file.id);
  var opts = {
    'url': url,
    'method': 'PUT',
    'headers': {
      'Authorization': util.format('Bearer %s', ctx.course.canvas.api_key)
    },
    'form': {
      'hidden': true
    }
  };
  request(opts, function(err, response, body) {
    if (err) {
      log.error({'err': err, 'course': ctx.course.id}, 'Failed to hide the file');
      return callback({'code': 500, 'msg': 'Failed to hide the file'});
    } else if (response.statusCode !== 200) {
      log.error({'err': err, 'course': ctx.course.id, 'body': body}, 'Failed to hide the file');
      return callback({'code': 500, 'msg': 'Failed to hide the file'});
    }

    return callback(null, file);
  });
};

/* Course users */

/**
 * Get the enrolled users of a course
 *
 * @param  {Course}         course                      The course for which to get the enrolled users
 * @param  {Object}         [options]                   A set of options
 * @param  {String[]}       [options.enrollment_state]  When set, only return users where the enrollment workflow state is of one of the given types. `active` and `invited` enrollments are returned by default. Should be one of @{link CollabosphereConstants.ENROLLMENT_STATE}
 * @param  {Function}       callback                    Standard callback function
 * @param  {Object}         callback.err                An error that occurred, if any
 * @param  {Object[]}       callback.users              The enrolled users of the given course
 */
var getCourseUsers = module.exports.getCourseUsers = function(course, options, callback) {
  options = options || {};

  log.debug({
    'course': course.id,
    'options': options
  }, 'Geting users');

  var url = util.format('/api/v1/courses/%d/users?', course.canvas_course_id);
  _.each(options.enrollment_state, function(state) {
    url += util.format('enrollment_state=%s&', state);
  });
  return getDataFromCanvas(course.canvas, url, callback);
};

/* Assignments */

/**
 * Get the assignments for a course
 *
 * @param  {Course}         course                    The course for which to get the assignments
 * @param  {Function}       callback                  Standard callback function
 * @param  {Object}         callback.err              An error that occurred, if any
 * @param  {Object[]}       callback.assignments      The assignments for the given course
 */
var getAssignments = module.exports.getAssignments = function(course, callback) {
  log.debug({
    'course': course.id
  }, 'Geting assignments');

  var url = util.format('/api/v1/courses/%d/assignments', course.canvas_course_id);
  return getDataFromCanvas(course.canvas, url, callback);
};

/**
 * Get the submissions for an assignment
 *
 * @param  {Course}         course                    The course for which to get the submissions
 * @param  {Object}         assignment                The assignment for which to get the submissions
 * @param  {Function}       callback                  Standard callback function
 * @param  {Object}         callback.err              An error that occurred, if any
 * @param  {Object[]}       callback.submissions      The submissions for the given assignment
 */
var getSubmissions = module.exports.getSubmissions = function(course, assignment, callback) {
  log.debug({
    'assignment': {
      'id': assignment.id,
      'name': assignment.name
    },
    'course': course.id
  }, 'Geting submissions');

  var url = util.format('/api/v1/courses/%d/assignments/%d/submissions', course.canvas_course_id, assignment.id);
  return getDataFromCanvas(course.canvas, url, callback);
};

/* Discussions */

/**
 * Get the discussions for a course
 *
 * @param  {Course}         course                    The course for which to get the discussions
 * @param  {Function}       callback                  Standard callback function
 * @param  {Object}         callback.err              An error that occurred, if any
 * @param  {Object[]}       callback.discussions      The discussions for the given course
 */
var getDiscussions = module.exports.getDiscussions = function(course, callback) {
  log.debug({
    'course': course.id
  }, 'Geting discussions');

  var url = util.format('/api/v1/courses/%d/discussion_topics', course.canvas_course_id);
  return getDataFromCanvas(course.canvas, url, callback);
};

/**
 * Get the entries on a discussion
 *
 * @param  {Course}         course                    The course for which to get the entries
 * @param  {Object}         discussion                The discussion for which to get the entries
 * @param  {Function}       callback                  Standard callback function
 * @param  {Object}         callback.err              An error that occurred, if any
 * @param  {Object[]}       callback.entries          The entries for the given discussion
 */
var getDiscussionEntries = module.exports.getDiscussionEntries = function(course, discussion, callback) {
  log.debug({
    'discussion': {
      'id': discussion.id,
      'name': discussion.name
    },
    'course': course.id
  }, 'Geting discussion entries');

  var url = util.format('/api/v1/courses/%d/discussion_topics/%d/entries', course.canvas_course_id, discussion.id);
  return getDataFromCanvas(course.canvas, url, callback);
};

/* Utilities */

/**
 * For security reasons, the canvas object on the course API usually only contains the `use_https`
 * and `canvas_api_domain` attributes. By reloading the instance, all other attributes such as
 * the `canvas_api_key` will be retrieved
 *
 * @param  {Canvas}         canvas            The canvas object to reload
 * @param  {Function}       callback          Standard callback function
 * @param  {Object}         callback.err      An error that occurred, if any
 * @api private
 */
var reloadCanvasObject = function(canvas, callback) {
  if (canvas.canvas_api_domain && canvas.canvas_api_key) {
    return callback();
  }

  // Reload the canvas object
  canvas.reload().complete(callback);
};

/**
 * Get the base URI on which a Canvas REST API can be reached. This includes
 * the protocol and hostname.
 *
 * @param  {Canvas}        canvas                 The canvas object for which to get the base URI
 * @return {String}                               The base URI where the Canvas API can be reached on
 * @api private
 */
var getBaseURI = function(canvas) {
  var canvasProtocol = (canvas.use_https ? 'https' : 'http');
  return util.format('%s://%s', canvasProtocol, canvas.canvas_api_domain);
};

/**
 * Get data from the Canvas REST API
 *
 * @param  {Canvas}         canvas                The canvas object that holds information about the REST API
 * @param  {String}         apiUrl                The API URL to get the data from
 * @param  {Function}       callback              Standard callback function
 * @param  {Object}         callback.err          An error that occurred, if any
 * @param  {Object}         callback.data         The data as returned by the Canvas REST API
 * @api private
 */
var getDataFromCanvas = function(canvas, apiUrl, callback, page, allData) {
  page = page || 1;
  allData = allData || [];

  reloadCanvasObject(canvas, function(err) {
    if (err) {
      return callback(err);
    }

    var opts = {
      'url': util.format('%s%s?page=%d&per_page=50', getBaseURI(canvas), apiUrl, page),
      'method': 'GET',
      'headers': {
        'Authorization': util.format('Bearer %s', canvas.api_key)
      }
    };
    var r = request(opts, function(err, response, body) {
      if (err) {
        log.error({'err': err, 'canvas': canvas.canvas_api_domain}, 'Failed to interact with the Canvas REST API');
        return callback({'code': 500, 'msg': 'Failed to interact with the Canvas REST API'});
      } else if (response.statusCode !== 200) {
        log.error({
          'err': err,
          'canvas': canvas.canvas_api_domain,
          'statusCode': response.statusCode,
          'body': body
        }, 'Canvas returned a non-200 status code');
        return callback({'code': 500, 'msg': 'Canvas returned a non-200 status code'});
      }

      // Canvas always returns JSON
      var data = null;
      try {
        data = JSON.parse(body);
      } catch (parseErr) {
        log.error({'err': parseErr, 'canvas': canvas.canvas_api_domain}, 'Failed to parse the Canvas response');
        return callback({'code': 500, 'msg': 'Failed to parse the Canvas data'});
      }

      allData = _.union(allData, data);

      // Check if there is more data to retrieve
      if (!_.isEmpty(data) && response.headers.link && response.headers.link.indexOf('rel="next"') > -1) {
        return getDataFromCanvas(canvas, apiUrl, callback, page + 1, allData);

      // If not, we return all the data to the caller
      } else {
        return callback(null, allData);
      }
    });
  });
};
