/**
 * Copyright 2015 UC Berkeley (UCB) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('lodash');
var assert = require('assert');

var ActivitiesDefault = require('col-activities/lib/default');
var ActivitiesTestUtil = require('col-activities/tests/util');
var CanvasPoller = require('col-canvas/lib/poller');
var DB = require('col-core/lib/db');
var TestsUtil = require('col-tests/lib/util');
var UsersTestUtil = require('col-users/tests/util');

var CanvasAssignment = require('./model').CanvasAssignment;
var CanvasDiscussion = require('./model').CanvasDiscussion;
var CanvasDiscussionEntry = require('./model').CanvasDiscussionEntry;
var CanvasFile = require('./model').CanvasFile;
var CanvasSubmission = require('./model').CanvasSubmission;
var CanvasTestsUtil = require('./util');
var CanvasUser = require('./model').CanvasUser;

describe('Canvas poller', function() {

  /**
   * Get a course object given a Canvas course id
   *
   * @param  {Number}           canvasCourseId      The id of the course in Canvas
   * @param  {Function}         callback            Invoked when the course has been retrieved
   * @param  {Course}           callback.course     The retrieved course object
   * @throws {AssertionError}                       Error thrown when an assertion failed
   */
  var getCourse = function(canvasCourseId, callback) {
    var options = {
      'where': {
        'canvas_course_id': canvasCourseId
      },
      'include': [{
        'model': DB.Canvas,
        'as': 'canvas'
      }]
    };
    DB.Course.findOne(options).complete(function(err, course) {
      assert.ok(!err);
      assert.ok(course);
      return callback(course);
    });
  };

  /**
   * Get a client in a course who has shared their points with the rest of the users in the course
   *
   * @param  {Course}         [course]              The course in which the client should be launched. If no course is provided, one will be created
   * @param  {Function}       callback              Standard callback function
   * @param  {RestClient}     callback.client       The client
   * @param  {Course}         callback.course       The course in which the client was launched
   * @param  {User}           callback.user         The user information of the client
   */
  var getClient = function(course, callback) {
    TestsUtil.getAssetLibraryClient(null, course, null, function(client, course, user) {
      UsersTestUtil.assertUpdateSharePoints(client, course, true, function() {
        return callback(client, course, user);
      });
    });
  };

  /**
   * Get a user by their name in a set of user objects
   *
   * @param  {CanvasUser[]}   users   The users to search through
   * @param  {String}         name    The name of the user to search for
   * @return {User}                   The user with the matching name, or `null` if no user with that name could be found
   */
  var getUserByName = function(users, name) {
    return _.findWhere(users, {'canvas_full_name': name});
  };

  /**
   * Get the points for an activity
   *
   * @param  {String}   name    The name of the activity to get the points for
   * @return {Number}           The points for the activity
   */
  var getActivitiesDefaultPoints = function(name) {
    return _.find(ActivitiesDefault, {'type': name}).points;
  };

  describe('Users', function() {

    /**
     * Test that verifies that the Canvas poller creates a record for users that haven't launched a tool yet
     */
    it('creates records for users that have not launched a tool yet', function(callback) {
      // Generate a test course
      getClient(null, function(client, course, user) {

        // Get the actual course object so we can pass it into the poller
        getCourse(course.id, function(dbCourse) {

          // Prepare the mocked requests to Canvas
          var mockedCanvasUsers = [new CanvasUser('Jack McJackerson')];
          CanvasTestsUtil.mockPollingRequests(dbCourse, mockedCanvasUsers);

          // Poll the Canvas API for information
          CanvasPoller.handleCourse(dbCourse, function(err) {
            assert.ok(!err);

            // The poller should've created a user account for Jack
            UsersTestUtil.assertGetUsers(client, course, 2, function(users) {
              assert.ok(getUserByName(users, 'Jack McJackerson'));

              // Verify there's only 1 Jack
              assert.strictEqual(_.groupBy(users, 'canvas_full_name')['Jack McJackerson'].length, 1);

              // Verify a subsequent run won't create another user record
              CanvasTestsUtil.mockPollingRequests(dbCourse, mockedCanvasUsers);
              CanvasPoller.handleCourse(dbCourse, function(err) {
                assert.ok(!err);
                UsersTestUtil.assertGetUsers(client, course, 2, function(users) {
                  return callback();
                });
              });
            });
          });
        });
      });
    });

    /**
     * Test that verifies that the poller can page the Canvas User REST API
     */
    it('can page Canvas', function(callback) {
      getClient(null, function(client, course, user) {

        // Get the actual course object so we can pass it into the poller
        getCourse(course.id, function(dbCourse) {

          // Prepare the mocked requests to Canvas
          var mockedCanvasUsers = _.times(100, function(n) {
            return new CanvasUser('Test student ' + n);
          });
          CanvasTestsUtil.mockPollingRequests(dbCourse, mockedCanvasUsers);

          // Poll the Canvas API for information
          CanvasPoller.handleCourse(dbCourse, function(err) {
            assert.ok(!err);

            // There should now be 101 users in the course, 100 users synced through the poller and 1
            // test client
            UsersTestUtil.assertGetUsers(client, course, 101, function(users) {
              return callback();
            });
          });
        });
      });
    });
  });

  describe('Assignments', function() {

    /**
     * Test that verifies that activities are created for submissions
     */
    it('creates activities for submissions', function(callback) {
      // Generate a test course with a few users who will make submissions
      getClient(null, function(client1, course, user1) {
        getClient(course, function(client2, course, user2) {
          getClient(course, function(client3, course, user3) {
            getClient(course, function(client4, course, user4) {

              // Get the actual course object so we can pass it into the poller
              getCourse(course.id, function(dbCourse) {

                // Poll the canvas API but don't return the assignment just yet
                CanvasTestsUtil.mockPollingRequests(dbCourse, [], [], []);
                CanvasPoller.handleCourse(dbCourse, function(err) {
                  assert.ok(!err);

                  // Get all the users, they should all have 0 points
                  UsersTestUtil.assertGetLeaderboard(client1, course, 4, false, function(users) {
                    _.each(users, function(user) {
                      assert.strictEqual(user.points, 0);
                    });

                    // Poll the Canvas API and return an assignment without any submissions
                    var assignments = [
                      new CanvasAssignment(course.id)
                    ];
                    CanvasTestsUtil.mockPollingRequests(dbCourse, [], assignments, []);
                    CanvasPoller.handleCourse(dbCourse, function(err) {
                      assert.ok(!err);

                      // All the users should still have 0 points
                      UsersTestUtil.assertGetLeaderboard(client1, course, 4, false, function(users) {
                        _.each(users, function(user) {
                          assert.strictEqual(user.points, 0);
                        });

                        // Poll the Canvas API and return an assignment with a few submissions
                        var assignments = [
                          new CanvasAssignment(course.id, [
                            new CanvasSubmission(user1.id, 'online_url', 'http://www.google.com'),
                            new CanvasSubmission(user2.id, 'online_text_entry', 'Here is my essay on ...'),
                            new CanvasSubmission(user3.id, 'online_upload', [
                              new CanvasFile('image/jpeg', 'Oh noes', 'ohnoes.jpg')
                            ])
                          ])
                        ];
                        CanvasTestsUtil.mockPollingRequests(dbCourse, [], assignments, []);
                        CanvasPoller.handleCourse(dbCourse, function(err) {
                          assert.ok(!err);

                          // All the users who made a submission should've received points
                          UsersTestUtil.assertGetLeaderboard(client1, course, 4, false, function(users) {

                            var expectedPoints = getActivitiesDefaultPoints('submit_assignment');
                            assert.strictEqual(getUserByName(users, user1.fullName).points, expectedPoints);
                            assert.strictEqual(getUserByName(users, user2.fullName).points, expectedPoints);
                            assert.strictEqual(getUserByName(users, user3.fullName).points, expectedPoints);

                            // Users without submissions don't get any points
                            assert.strictEqual(getUserByName(users, user4.fullName).points, 0);

                            // Subsequent polls should not result in new activities
                            CanvasTestsUtil.mockPollingRequests(dbCourse, [], assignments, []);
                            CanvasPoller.handleCourse(dbCourse, function(err) {
                              assert.ok(!err);
                              UsersTestUtil.assertGetLeaderboard(client1, course, 4, false, function(users) {
                                assert.strictEqual(getUserByName(users, user1.fullName).points, expectedPoints);
                                assert.strictEqual(getUserByName(users, user2.fullName).points, expectedPoints);
                                assert.strictEqual(getUserByName(users, user3.fullName).points, expectedPoints);
                                assert.strictEqual(getUserByName(users, user4.fullName).points, 0);

                                return callback();
                              });
                            });
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });

    /**
     * Test that verifies that the poller can page the Canvas Assignments REST API
     */
    it('can page Canvas', function(callback) {
      getClient(null, function(client, course, user) {

        // Get the actual course object so we can pass it into the poller
        getCourse(course.id, function(dbCourse) {

          // Prepare the mocked requests to Canvas
          var assignments = _.times(100, function(n) {
            return new CanvasAssignment(course.id, [
              new CanvasSubmission(user.id, 'online_url', 'http://www.google.com')
            ]);
          });
          CanvasTestsUtil.mockPollingRequests(dbCourse, [], assignments);

          // Poll the Canvas API for information
          CanvasPoller.handleCourse(dbCourse, function(err) {
            assert.ok(!err);

            // The test user made a 100 submissions which should result in earning 2000 points
            UsersTestUtil.assertGetLeaderboard(client, course, 1, false, function(leaderboard) {
              assert.strictEqual(leaderboard[0].points, 2000);
              return callback();
            });
          });
        });
      });
    });

    /**
     * Test that verifies that re-submissions don't create extra activities or points
     */
    it('does not create activities for re-submissions', function(callback) {
      getClient(null, function(client1, course, user1) {

        // Get the actual course object so we can pass it into the poller
        getCourse(course.id, function(dbCourse) {

          // Poll the Canvas API and return an assignment with a few submissions
          var assignments = [
            new CanvasAssignment(course.id, [
              new CanvasSubmission(user1.id, 'online_url', 'http://www.google.com')
            ])
          ];
          CanvasTestsUtil.mockPollingRequests(dbCourse, [], assignments, []);
          CanvasPoller.handleCourse(dbCourse, function(err) {
            assert.ok(!err);

            // Get the leaderboard so we can check the points don't change
            UsersTestUtil.assertGetLeaderboard(client1, course, 1, false, function(oldLeaderboard) {

              // Re-submit an assignment and change the type
              assignments[0].submissions[0].attempts++;
              assignments[0].submissions[0].submission_type = 'online_upload';
              assignments[0].submissions[0].attachments = [new CanvasFile('image/jpeg', 'Oh noes', 'ohnoes.jpg')];
              CanvasTestsUtil.mockPollingRequests(dbCourse, [], assignments, []);
              CanvasPoller.handleCourse(dbCourse, function(err) {
                assert.ok(!err);

                // Ensure the points didn't change
                UsersTestUtil.assertGetLeaderboard(client1, course, 1, false, function(newLeaderboard) {
                  assert.deepEqual(oldLeaderboard, newLeaderboard);

                  return callback();
                });
              });
            });
          });
        });
      });
    });

    /**
     * Test that verifies that the poller uses the configured activity type configuration when scoring activities
     */
    it('uses the configured activity type configuration for scoring', function(callback) {
      getClient(null, function(client1, course, user1) {
        var adminUser = TestsUtil.generateAdminUser();
        TestsUtil.getAssetLibraryClient(null, course, adminUser, function(adminClient, course, adminUser) {

          // Configure a new point setting for assignment submissions
          ActivitiesTestUtil.assertEditActivityTypeConfiguration(adminClient, course, 'submit_assignment', 42, null, function() {

            // Get the actual course object so we can pass it into the poller
            getCourse(course.id, function(dbCourse) {

              // Poll the Canvas API and return an assignment with a few submissions
              var assignments = [
                new CanvasAssignment(course.id, [
                  new CanvasSubmission(user1.id, 'online_url', 'http://www.google.com')
                ])
              ];
              CanvasTestsUtil.mockPollingRequests(dbCourse, [], assignments, []);
              CanvasPoller.handleCourse(dbCourse, function(err) {
                assert.ok(!err);

                // Get the leaderboard and verify the user got the configured amount of points
                UsersTestUtil.assertGetLeaderboard(client1, course, 1, false, function(leaderboard) {
                  assert.strictEqual(leaderboard[0].points, 42);
                  return callback();
                });
              });
            });
          });
        });
      });
    });
  });

  describe('Discussions', function() {

    /**
     * Test that verifies that activities are created for discussions
     */
    it('creates activities for submissions', function(callback) {
      // Generate a test course with a few users who will add entries
      getClient(null, function(client1, course, user1) {
        getClient(course, function(client2, course, user2) {
          getClient(course, function(client3, course, user3) {

            // Get the actual course object so we can pass it into the poller
            getCourse(course.id, function(dbCourse) {

              // Poll the canvas API but don't return a discussion just yet
              CanvasTestsUtil.mockPollingRequests(dbCourse, [], [], []);
              CanvasPoller.handleCourse(dbCourse, function(err) {
                assert.ok(!err);

                // Get all the users, they should all have 0 points
                UsersTestUtil.assertGetLeaderboard(client1, course, 3, false, function(users) {
                  _.each(users, function(user) {
                    assert.strictEqual(user.points, 0);
                  });

                  // Poll the Canvas API and return the discussion
                  var discussion = new CanvasDiscussion(user1);
                  CanvasTestsUtil.mockPollingRequests(dbCourse, [], [], [discussion]);
                  CanvasPoller.handleCourse(dbCourse, function(err) {
                    assert.ok(!err);

                    var topicPoints = getActivitiesDefaultPoints('discussion_topic');
                    var entryPoints = getActivitiesDefaultPoints('discussion_entry');
                    var entryGetReplyPoints = getActivitiesDefaultPoints('get_discussion_entry_reply');

                    // The user who created the discussion should've received points
                    UsersTestUtil.assertGetLeaderboard(client1, course, 3, false, function(users) {
                      assert.strictEqual(getUserByName(users, user1.fullName).points, topicPoints);
                      assert.strictEqual(getUserByName(users, user2.fullName).points, 0);
                      assert.strictEqual(getUserByName(users, user3.fullName).points, 0);

                      // Subsequent polls should not result in new activities
                      CanvasTestsUtil.mockPollingRequests(dbCourse, [], [], [discussion]);
                      CanvasPoller.handleCourse(dbCourse, function(err) {
                        assert.ok(!err);
                        UsersTestUtil.assertGetLeaderboard(client1, course, 3, false, function(users) {
                          assert.strictEqual(getUserByName(users, user1.fullName).points, topicPoints);
                          assert.strictEqual(getUserByName(users, user2.fullName).points, 0);
                          assert.strictEqual(getUserByName(users, user3.fullName).points, 0);

                          // Add an entry to a discussion
                          discussion.addEntry(new CanvasDiscussionEntry(user2));
                          CanvasTestsUtil.mockPollingRequests(dbCourse, [], [], [discussion]);
                          CanvasPoller.handleCourse(dbCourse, function(err) {
                            assert.ok(!err);

                            // The user who added an entry on the discussion should now also have some points
                            UsersTestUtil.assertGetLeaderboard(client1, course, 3, false, function(users) {
                              assert.strictEqual(getUserByName(users, user1.fullName).points, topicPoints);
                              assert.strictEqual(getUserByName(users, user2.fullName).points, entryPoints);
                              assert.strictEqual(getUserByName(users, user3.fullName).points, 0);

                              // Reply to an entry
                              discussion.addEntry(new CanvasDiscussionEntry(user3, discussion.getEntries()[0].id));
                              CanvasTestsUtil.mockPollingRequests(dbCourse, [], [], [discussion]);
                              CanvasPoller.handleCourse(dbCourse, function(err) {
                                assert.ok(!err);

                                // The user who replied to an entry should've received some points. The user
                                // who made the original entry will get additional points
                                UsersTestUtil.assertGetLeaderboard(client1, course, 3, false, function(users) {
                                  assert.strictEqual(getUserByName(users, user1.fullName).points, topicPoints);
                                  assert.strictEqual(getUserByName(users, user2.fullName).points, entryPoints + entryGetReplyPoints);
                                  assert.strictEqual(getUserByName(users, user3.fullName).points, entryPoints);

                                  return callback();
                                });
                              });
                            });
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });

    /**
     * Test that verifies that the poller can page the Canvas Discussions REST API
     */
    it('can page Canvas', function(callback) {
      // We need to bump the timeout for this test as the Canvas poller will add a bit of delay
      // between each request. Because of the number of requests this test will generate, we need
      // a larger test timeout
      this.timeout(5000);

      // Generate a test course with a few users who will add entries
      getClient(null, function(client1, course, user1) {
        getClient(course, function(client2, course, user2) {
          getClient(course, function(client3, course, user3) {

            // Get the actual course object so we can pass it into the poller
            getCourse(course.id, function(dbCourse) {

              // Prepare the mocked requests to Canvas
              var discussions = _.times(100, function(n) {
                return new CanvasDiscussion(user1);
              });
              CanvasTestsUtil.mockPollingRequests(dbCourse, [], [], discussions);

              // Poll the Canvas API for information
              CanvasPoller.handleCourse(dbCourse, function(err) {
                assert.ok(!err);

                // The first user made a 100 discussion topics which should result in earning 500 points
                UsersTestUtil.assertGetLeaderboard(client1, course, 3, false, function(leaderboard) {
                  assert.strictEqual(getUserByName(leaderboard, user1.fullName).points, 100 * getActivitiesDefaultPoints('discussion_topic'));
                  assert.strictEqual(getUserByName(leaderboard, user2.fullName).points, 0);
                  assert.strictEqual(getUserByName(leaderboard, user3.fullName).points, 0);

                  // Add 100 entries
                  _.each(discussions, function(discussion) {
                    discussion.addEntry(new CanvasDiscussionEntry(user2));
                  });
                  CanvasTestsUtil.mockPollingRequests(dbCourse, [], [], discussions);

                  // Poll the Canvas API for information
                  CanvasPoller.handleCourse(dbCourse, function(err) {
                    assert.ok(!err);

                    // The second user made a 100 entries which should result in earning 300 points
                    UsersTestUtil.assertGetLeaderboard(client1, course, 3, false, function(leaderboard) {
                      assert.strictEqual(getUserByName(leaderboard, user1.fullName).points, 100 * getActivitiesDefaultPoints('discussion_topic'));
                      assert.strictEqual(getUserByName(leaderboard, user2.fullName).points, 100 * getActivitiesDefaultPoints('discussion_entry'));
                      assert.strictEqual(getUserByName(leaderboard, user3.fullName).points, 0);

                      // Add 100 replies to entries
                      _.each(discussions, function(discussion) {
                        discussion.addEntry(new CanvasDiscussionEntry(user3, discussion.getEntries()[0].id));
                      });
                      CanvasTestsUtil.mockPollingRequests(dbCourse, [], [], discussions);

                      // Poll the Canvas API for information
                      CanvasPoller.handleCourse(dbCourse, function(err) {
                        assert.ok(!err);

                        // The third user made a 100 replies which should result in earning 200 points. Additionally
                        // the second user should've received a 100 points extra for getting 100 replies to their entries
                        UsersTestUtil.assertGetLeaderboard(client1, course, 3, false, function(leaderboard) {
                          assert.strictEqual(getUserByName(leaderboard, user1.fullName).points, 100 * getActivitiesDefaultPoints('discussion_topic'));
                          assert.strictEqual(getUserByName(leaderboard, user2.fullName).points, (100 * getActivitiesDefaultPoints('discussion_entry')) + (100 * getActivitiesDefaultPoints('get_discussion_entry_reply')));
                          assert.strictEqual(getUserByName(leaderboard, user3.fullName).points, 100 * getActivitiesDefaultPoints('discussion_entry'));
                          return callback();
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
});
