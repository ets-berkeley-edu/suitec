/**
 * Copyright 2015 UC Berkeley (UCB) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('lodash');
var assert = require('assert');

var ActivitiesDefault = require('col-activities/lib/default');
var ActivitiesTestUtil = require('col-activities/tests/util');
var AssetsTestsUtil = require('col-assets/tests/util');
var CanvasPoller = require('col-canvas/lib/poller');
var CanvasTestsModel = require('col-canvas/tests/model');
var CategoriesTestUtil = require('col-categories/tests/util');
var CollabosphereConstants = require('col-core/lib/constants');
var DB = require('col-core/lib/db');
var TestsUtil = require('col-tests/lib/util');
var UsersAPI = require('col-users');
var UsersTestUtil = require('col-users/tests/util');

var CanvasAssignment = require('./model').CanvasAssignment;
var CanvasDiscussion = require('./model').CanvasDiscussion;
var CanvasDiscussionEntry = require('./model').CanvasDiscussionEntry;
var CanvasFile = require('./model').CanvasFile;
var CanvasSubmission = require('./model').CanvasSubmission;
var CanvasTestsUtil = require('./util');
var CanvasUser = require('./model').CanvasUser;

describe('Canvas poller', function() {

  /**
   * Get a course object given a Canvas course id
   *
   * @param  {Number}           canvasCourseId      The id of the course in Canvas
   * @param  {Function}         callback            Invoked when the course has been retrieved
   * @param  {Course}           callback.course     The retrieved course object
   * @throws {AssertionError}                       Error thrown when an assertion failed
   */
  var getCourse = function(canvasCourseId, callback) {
    var options = {
      'where': {
        'canvas_course_id': canvasCourseId
      },
      'include': [{
        'model': DB.Canvas,
        'as': 'canvas'
      }]
    };
    DB.Course.findOne(options).complete(function(err, course) {
      assert.ok(!err);
      assert.ok(course);
      return callback(course);
    });
  };

  /**
   * Get a client in a course who has shared their points with the rest of the users in the course
   *
   * @param  {Course}         [course]              The course in which the client should be launched. If no course is provided, one will be created
   * @param  {Function}       callback              Standard callback function
   * @param  {RestClient}     callback.client       The client
   * @param  {Course}         callback.course       The course in which the client was launched
   * @param  {User}           callback.user         The user information of the client
   */
  var getClient = function(course, callback) {
    TestsUtil.getAssetLibraryClient(null, course, null, function(client, course, user) {
      UsersTestUtil.assertUpdateSharePoints(client, course, true, function() {
        return callback(client, course, user);
      });
    });
  };

  /**
   * Get a user by their name in a set of user objects
   *
   * @param  {CanvasUser[]}   users   The users to search through
   * @param  {String}         name    The name of the user to search for
   * @return {User}                   The user with the matching name, or `null` if no user with that name could be found
   */
  var getUserByName = function(users, name) {
    return _.findWhere(users, {'canvas_full_name': name});
  };

  /**
   * Get the points for an activity
   *
   * @param  {String}   name    The name of the activity to get the points for
   * @return {Number}           The points for the activity
   */
  var getActivitiesDefaultPoints = function(name) {
    return _.find(ActivitiesDefault, {'type': name}).points;
  };

  describe('Users', function() {

    /**
     * Test that verifies that the Canvas poller creates a record for users that haven't launched a tool yet
     */
    it('creates records for users that have not launched a tool yet', function(callback) {
      // Generate a test course
      getClient(null, function(client, course, user) {

        // Get the actual course object so we can pass it into the poller
        getCourse(course.id, function(dbCourse) {

          // Prepare the mocked requests to Canvas
          var mockedCanvasUsers = [
            new CanvasUser('Active student', course.id, 'active'),
            new CanvasUser('Active teacher', course.id, 'active', 'TeacherEnrollment'),
            new CanvasUser('Completed student', course.id, 'completed')
          ];
          CanvasTestsUtil.mockPollingRequests(dbCourse, mockedCanvasUsers);

          // Poll the Canvas API for information
          CanvasPoller.handleCourse(dbCourse, function(err) {
            assert.ok(!err);

            // The poller should've created user accounts for each user. Note that we can't use
            // the UsersTestsUtil.assertGetAllUsers function here as the REST endpoint it uses will
            // only return the active and invited users
            var ctx = {'course': dbCourse};
            UsersAPI.getAllUsers(ctx, _.values(CollabosphereConstants.ENROLLMENT_STATE), function(err, users) {
              assert.ok(!err);
              assert.strictEqual(users.length, 4);

              var activeStudent = getUserByName(users, 'Active student');
              UsersTestUtil.assertUser(activeStudent);
              assert.strictEqual(activeStudent.canvas_course_role, 'Student');
              assert.strictEqual(activeStudent.canvas_enrollment_state, 'active');

              var completedStudent = getUserByName(users, 'Completed student');
              UsersTestUtil.assertUser(completedStudent);
              assert.strictEqual(completedStudent.canvas_course_role, 'Student');
              assert.strictEqual(completedStudent.canvas_enrollment_state, 'completed');

              var teacher = getUserByName(users, 'Active teacher');
              UsersTestUtil.assertUser(teacher);
              assert.strictEqual(teacher.canvas_course_role, 'Instructor');
              assert.strictEqual(teacher.canvas_enrollment_state, 'active');

              // Verify a subsequent run won't create another user record
              CanvasTestsUtil.mockPollingRequests(dbCourse, mockedCanvasUsers);
              CanvasPoller.handleCourse(dbCourse, function(err) {
                assert.ok(!err);

                UsersAPI.getAllUsers(ctx, _.values(CollabosphereConstants.ENROLLMENT_STATE), function(err, users) {
                  assert.ok(!err);
                  assert.strictEqual(users.length, 4);
                  UsersTestUtil.assertUser(getUserByName(users, 'Active student'));
                  UsersTestUtil.assertUser(getUserByName(users, 'Completed student'));
                  UsersTestUtil.assertUser(getUserByName(users, 'Active teacher'));
                  return callback();
                });
              });
            });
          });
        });
      });
    });

    /**
     * Test that verifies that the poller can page the Canvas User REST API
     */
    it('can page Canvas', function(callback) {
      getClient(null, function(client, course, user) {

        // Get the actual course object so we can pass it into the poller
        getCourse(course.id, function(dbCourse) {

          // Prepare the mocked requests to Canvas
          var mockedCanvasUsers = _.times(100, function(n) {
            return new CanvasUser('Test student ' + n);
          });
          CanvasTestsUtil.mockPollingRequests(dbCourse, mockedCanvasUsers);

          // Poll the Canvas API for information
          CanvasPoller.handleCourse(dbCourse, function(err) {
            assert.ok(!err);

            // There should now be 101 users in the course, 100 users synced through the poller and 1
            // test client
            var ctx = {'course': dbCourse};
            UsersAPI.getAllUsers(ctx, _.values(CollabosphereConstants.ENROLLMENT_STATE), function(err, users) {
              assert.ok(!err);
              assert.strictEqual(users.length, 101);
              return callback();
            });
          });
        });
      });
    });

    /**
     * Test that verifies that the poller updates user records if user information changes in Canvas
     */
    it('updates user records if user information changes in Canvas', function(callback) {
      // Generate a test course
      getClient(null, function(client, course, user) {

        // Get the actual course object so we can pass it into the poller
        getCourse(course.id, function(dbCourse) {

          // Prepare the mocked requests to Canvas
          var mockedCanvasUsers = [new CanvasUser('Jack McJackerson')];
          CanvasTestsUtil.mockPollingRequests(dbCourse, mockedCanvasUsers);

          // Poll the Canvas API for information
          CanvasPoller.handleCourse(dbCourse, function(err) {
            assert.ok(!err);

            // The poller should've created a user account for Jack
            var ctx = {'course': dbCourse};
            UsersAPI.getAllUsers(ctx, _.values(CollabosphereConstants.ENROLLMENT_STATE), function(err, users) {
              assert.ok(!err);
              assert.strictEqual(users.length, 2);
              assert.ok(getUserByName(users, 'Jack McJackerson'));

              // Update Jack's name in Canvas
              mockedCanvasUsers[0].name = 'Jack "Jacko" McJackerson';
              CanvasTestsUtil.mockPollingRequests(dbCourse, mockedCanvasUsers);
              CanvasPoller.handleCourse(dbCourse, function(err) {
                assert.ok(!err);

                // The poller should've updated Jack's user account
                UsersAPI.getAllUsers(ctx, _.values(CollabosphereConstants.ENROLLMENT_STATE), function(err, users) {
                  assert.ok(!err);
                  assert.strictEqual(users.length, 2);
                  var user = getUserByName(users, 'Jack "Jacko" McJackerson');
                  assert.ok(user);
                  return callback();
                });
              });
            });
          });
        });
      });
    });
  });

  describe('Assignments', function() {

    /**
     * Test that verifies that activities are created for submissions
     */
    it('creates activities for submissions', function(callback) {
      // Generate a test course with a few users who will make submissions
      getClient(null, function(client1, course, user1) {
        getClient(course, function(client2, course, user2) {
          getClient(course, function(client3, course, user3) {
            getClient(course, function(client4, course, user4) {

              // Get the actual course object so we can pass it into the poller
              getCourse(course.id, function(dbCourse) {

                // Poll the canvas API but don't return the assignment just yet
                var mockedUsers = [
                  CanvasTestsModel.getCanvasUser(user1, course),
                  CanvasTestsModel.getCanvasUser(user2, course),
                  CanvasTestsModel.getCanvasUser(user3, course),
                  CanvasTestsModel.getCanvasUser(user4, course)
                ];
                CanvasTestsUtil.mockPollingRequests(dbCourse, mockedUsers, [], []);
                CanvasPoller.handleCourse(dbCourse, function(err) {
                  assert.ok(!err);

                  // Get all the users, they should all have 0 points
                  UsersTestUtil.assertGetLeaderboard(client1, course, 4, false, function(users) {
                    _.each(users, function(user) {
                      assert.strictEqual(user.points, 0);
                    });

                    // Poll the Canvas API and return an assignment without any submissions
                    var assignments = [
                      new CanvasAssignment(course.id)
                    ];
                    CanvasTestsUtil.mockPollingRequests(dbCourse, mockedUsers, assignments, []);
                    CanvasPoller.handleCourse(dbCourse, function(err) {
                      assert.ok(!err);

                      // All the users should still have 0 points
                      UsersTestUtil.assertGetLeaderboard(client1, course, 4, false, function(users) {
                        _.each(users, function(user) {
                          assert.strictEqual(user.points, 0);
                        });

                        // Poll the Canvas API and return an assignment with a few submissions
                        var assignments = [
                          new CanvasAssignment(course.id, [
                            new CanvasSubmission(user1.id, 'online_url', 'http://www.google.com'),
                            new CanvasSubmission(user2.id, 'online_text_entry', 'Here is my essay on ...'),
                            new CanvasSubmission(user3.id, 'online_upload', [
                              new CanvasFile('image/jpeg', 'Oh noes', 'ohnoes.jpg')
                            ])
                          ])
                        ];
                        CanvasTestsUtil.mockPollingRequests(dbCourse, mockedUsers, assignments, []);
                        CanvasPoller.handleCourse(dbCourse, function(err) {
                          assert.ok(!err);

                          // All the users who made a submission should've received points
                          UsersTestUtil.assertGetLeaderboard(client1, course, 4, false, function(users) {

                            var expectedPoints = getActivitiesDefaultPoints('submit_assignment');
                            assert.strictEqual(getUserByName(users, user1.fullName).points, expectedPoints);
                            assert.strictEqual(getUserByName(users, user2.fullName).points, expectedPoints);
                            assert.strictEqual(getUserByName(users, user3.fullName).points, expectedPoints);

                            // Users without submissions don't get any points
                            assert.strictEqual(getUserByName(users, user4.fullName).points, 0);

                            // Subsequent polls should not result in new activities
                            assignments[0].submissions[2].attachments[0].expectProcessing = false;
                            CanvasTestsUtil.mockPollingRequests(dbCourse, mockedUsers, assignments, []);
                            CanvasPoller.handleCourse(dbCourse, function(err) {
                              assert.ok(!err);
                              UsersTestUtil.assertGetLeaderboard(client1, course, 4, false, function(users) {
                                assert.strictEqual(getUserByName(users, user1.fullName).points, expectedPoints);
                                assert.strictEqual(getUserByName(users, user2.fullName).points, expectedPoints);
                                assert.strictEqual(getUserByName(users, user3.fullName).points, expectedPoints);
                                assert.strictEqual(getUserByName(users, user4.fullName).points, 0);

                                return callback();
                              });
                            });
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });

    /**
     * Test that verifies that the poller can page the Canvas Assignments REST API
     */
    it('can page Canvas', function(callback) {
      getClient(null, function(client, course, user) {

        // Get the actual course object so we can pass it into the poller
        getCourse(course.id, function(dbCourse) {

          // Prepare the mocked requests to Canvas
          var assignments = _.times(100, function(n) {
            return new CanvasAssignment(course.id, [
              new CanvasSubmission(user.id, 'online_url', 'http://www.google.com')
            ]);
          });
          var mockedUsers = [
            CanvasTestsModel.getCanvasUser(user, course)
          ];
          CanvasTestsUtil.mockPollingRequests(dbCourse, mockedUsers, assignments);

          // Poll the Canvas API for information
          CanvasPoller.handleCourse(dbCourse, function(err) {
            assert.ok(!err);

            // The test user made a 100 submissions which should result in earning 2000 points
            UsersTestUtil.assertGetLeaderboard(client, course, 1, false, function(leaderboard) {
              assert.strictEqual(leaderboard[0].points, 2000);
              return callback();
            });
          });
        });
      });
    });

    /**
     * Test that verifies that re-submissions don't create extra activities or points
     */
    it('does not create activities for re-submissions', function(callback) {
      getClient(null, function(client1, course, user1) {

        // Get the actual course object so we can pass it into the poller
        getCourse(course.id, function(dbCourse) {

          // Poll the Canvas API and return an assignment with a few submissions
          var mockedUsers = [
            CanvasTestsModel.getCanvasUser(user1, course)
          ];
          var assignments = [
            new CanvasAssignment(course.id, [
              new CanvasSubmission(user1.id, 'online_url', 'http://www.google.com')
            ])
          ];
          CanvasTestsUtil.mockPollingRequests(dbCourse, mockedUsers, assignments, []);
          CanvasPoller.handleCourse(dbCourse, function(err) {
            assert.ok(!err);

            // Get the leaderboard so we can check the points don't change
            UsersTestUtil.assertGetLeaderboard(client1, course, 1, false, function(oldLeaderboard) {

              // Re-submit an assignment and change the type
              assignments[0].submissions[0].attempt++;
              assignments[0].submissions[0].submission_type = 'online_upload';
              assignments[0].submissions[0].attachments = [new CanvasFile('image/jpeg', 'Oh noes', 'ohnoes.jpg')];
              CanvasTestsUtil.mockPollingRequests(dbCourse, mockedUsers, assignments, []);
              CanvasPoller.handleCourse(dbCourse, function(err) {
                assert.ok(!err);

                // Ensure the points didn't change
                UsersTestUtil.assertGetLeaderboard(client1, course, 1, false, function(newLeaderboard) {
                  assert.deepEqual(oldLeaderboard, newLeaderboard);

                  // Re-submit the assignment again and ensure the points don't change
                  assignments[0].submissions[0].attempt++;
                  CanvasTestsUtil.mockPollingRequests(dbCourse, mockedUsers, assignments, []);
                  CanvasPoller.handleCourse(dbCourse, function(err) {
                    assert.ok(!err);

                    // Ensure the points didn't change
                    UsersTestUtil.assertGetLeaderboard(client1, course, 1, false, function(newLeaderboard) {
                      assert.deepEqual(oldLeaderboard, newLeaderboard);

                      return callback();
                    });
                  });
                });
              });
            });
          });
        });
      });
    });

    /**
     * Test that verifies that the poller uses the configured activity type configuration when scoring activities
     */
    it('uses the configured activity type configuration for scoring', function(callback) {
      getClient(null, function(client1, course, user1) {
        var instructor = TestsUtil.generateInstructor();
        TestsUtil.getAssetLibraryClient(null, course, instructor, function(instructorClient, course, instructor) {

          // Configure a new point setting for assignment submissions
          var config = [{'type': 'submit_assignment', 'points': 42, 'enabled': true}];
          ActivitiesTestUtil.assertEditActivityTypeConfiguration(instructorClient, course, config, function() {

            // Get the actual course object so we can pass it into the poller
            getCourse(course.id, function(dbCourse) {

              // Poll the Canvas API and return an assignment with a few submissions
              var mockedUsers = [
                CanvasTestsModel.getCanvasUser(user1, course)
              ];
              var assignments = [
                new CanvasAssignment(course.id, [
                  new CanvasSubmission(user1.id, 'online_url', 'http://www.google.com')
                ])
              ];
              CanvasTestsUtil.mockPollingRequests(dbCourse, mockedUsers, assignments, []);
              CanvasPoller.handleCourse(dbCourse, function(err) {
                assert.ok(!err);

                // Get the leaderboard and verify the user got the configured amount of points
                UsersTestUtil.assertGetLeaderboard(client1, course, 1, false, function(leaderboard) {
                  assert.strictEqual(leaderboard[0].points, 42);
                  return callback();
                });
              });
            });
          });
        });
      });
    });

    /**
     * Test that verifies that the poller creates assets for file submissions
     */
    it('creates assets for file submissions', function(callback) {
      // Generate a test course with a few users who will make submissions
      getClient(null, function(client1, course, user1) {
        getClient(course, function(client2, course, user2) {
          getClient(course, function(client3, course, user3) {
            getClient(course, function(client4, course, user4) {

              // Get the actual course object so we can pass it into the poller
              getCourse(course.id, function(dbCourse) {

                // Each user submits something different
                var user1Submission = new CanvasSubmission(user1.id, 'online_url', 'http://www.google.com');
                var user2Submission = new CanvasSubmission(user2.id, 'online_text_entry', 'Here is my essay on ...');
                var user3Submission = new CanvasSubmission(user3.id, 'online_upload', [
                  new CanvasFile('image/jpeg', 'File 1', 'file1.jpg')
                ]);
                var user4Submission = new CanvasSubmission(user4.id, 'online_upload', [
                  new CanvasFile('image/jpeg', 'File 2.1', 'file2.1.jpg'),
                  new CanvasFile('image/jpeg', 'File 2.2', 'file2.2.jpg')
                ]);
                var assignments = [
                  new CanvasAssignment(course.id, [user1Submission, user2Submission, user3Submission, user4Submission])
                ];
                CanvasTestsUtil.mockPollingRequests(dbCourse, [], assignments, []);
                CanvasPoller.handleCourse(dbCourse, function(err) {
                  assert.ok(!err);

                  // Assert the assets were created
                  AssetsTestsUtil.assertGetAssets(client1, course, null, null, null, 4, function(assets) {
                    // Assert the link was created correctly
                    var linkAsset = _.find(assets.results, {'type': 'link'});
                    assert.ok(linkAsset);
                    assert.strictEqual(linkAsset.title, 'http://www.google.com');
                    assert.strictEqual(linkAsset.url, 'http://www.google.com');

                    // Assert user3's file was created correctly
                    assert.ok(_.find(assets.results, {'type': 'file', 'title': 'File 1'}));

                    // Assert user4's files were created correctly
                    assert.ok(_.find(assets.results, {'type': 'file', 'title': 'File 2.1'}));
                    assert.ok(_.find(assets.results, {'type': 'file', 'title': 'File 2.2'}));

                    // Verify that polling again won't create any additional assets
                    assignments[0].submissions[2].attachments[0].expectProcessing = false;
                    assignments[0].submissions[3].attachments[0].expectProcessing = false;
                    assignments[0].submissions[3].attachments[1].expectProcessing = false;
                    CanvasTestsUtil.mockPollingRequests(dbCourse, [], assignments, []);
                    CanvasPoller.handleCourse(dbCourse, function(err) {
                      assert.ok(!err);
                      AssetsTestsUtil.assertGetAssets(client1, course, null, null, null, 4, function(newAssets) {
                        var newAssetIds = _.pluck(newAssets.results, 'id');
                        var oldAssetIds = _.pluck(assets.results, 'id');
                        assert.strictEqual(_.intersection(newAssetIds, oldAssetIds).length, 4);

                        // Verify that resubmitting each assignment causes the files to be deleted
                        user1Submission.attempt++;
                        user1Submission.url = 'http://www.yahoo.com';
                        user2Submission.attempt++;
                        user2Submission.body = 'My new essay';
                        user3Submission.attempt++;
                        user3Submission.attachments = [
                          new CanvasFile('image/jpeg', 'File 1-updated', 'file1-updated.jpg')
                        ];
                        user4Submission.attempt++;
                        user4Submission.attachments = [
                          new CanvasFile('image/jpeg', 'File 2.1-updated', 'file2.1-updated.jpg'),
                          new CanvasFile('image/jpeg', 'File 2.2-updated', 'file2.2-updated.jpg')
                        ];
                        CanvasTestsUtil.mockPollingRequests(dbCourse, [], assignments, []);
                        CanvasPoller.handleCourse(dbCourse, function(err) {
                          assert.ok(!err);

                          // Assert the old assets have been removed
                          AssetsTestsUtil.assertGetAssets(client1, course, null, null, null, 4, function(newAssets) {
                            // Assert these are all new assets
                            newAssetIds = _.pluck(newAssets.results, 'id');
                            assert.strictEqual(_.intersection(newAssetIds, oldAssetIds).length, 0);

                            // Assert the link was created correctly
                            var linkAsset = _.find(newAssets.results, {'type': 'link'});
                            assert.ok(linkAsset);
                            assert.strictEqual(linkAsset.title, 'http://www.yahoo.com');
                            assert.strictEqual(linkAsset.url, 'http://www.yahoo.com');

                            // Assert user3's file was created correctly
                            assert.ok(_.find(newAssets.results, {'type': 'file', 'title': 'File 1-updated'}));

                            // Assert user4's files were created correctly
                            assert.ok(_.find(newAssets.results, {'type': 'file', 'title': 'File 2.1-updated'}));
                            assert.ok(_.find(newAssets.results, {'type': 'file', 'title': 'File 2.2-updated'}));
                            return callback();
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });

    /**
     * Test that verifies that the poller removes outdated submissions from the asset library
     */
    it('removes outdated submissions from the asset library', function(callback) {
      // Generate a test course with a user who will make submissions
      getClient(null, function(client1, course, user1) {

        // Verify there are no assets in the library yet
        AssetsTestsUtil.assertGetAssets(client1, course, null, null, null, 0, function(assets) {

          // Get the actual course object so we can pass it into the poller
          getCourse(course.id, function(dbCourse) {

            // Submit a file
            var assignments = [
              new CanvasAssignment(course.id, [
                new CanvasSubmission(user1.id, 'online_upload', [
                  new CanvasFile('image/jpeg', 'File 1', 'file1.jpg')
                ])
              ])
            ];
            CanvasTestsUtil.mockPollingRequests(dbCourse, [], assignments, []);
            CanvasPoller.handleCourse(dbCourse, function(err) {
              assert.ok(!err);

              // Verify an asset was added for the submission
              AssetsTestsUtil.assertGetAssets(client1, course, null, null, null, 1, function(assets) {
                var fileAsset = assets.results[0];

                // The user re-submits their assignment
                assignments[0].submissions[0].attempt++;
                assignments[0].submissions[0].attachments = [new CanvasFile('image/jpeg', 'File 1-updated', 'file1-updated.jpg')];
                CanvasTestsUtil.mockPollingRequests(dbCourse, [], assignments, []);
                CanvasPoller.handleCourse(dbCourse, function(err) {
                  assert.ok(!err);

                  // The previous asset should be replaced
                  AssetsTestsUtil.assertGetAssets(client1, course, null, null, null, 1, function(assets) {
                    var newAsset = assets.results[0];
                    assert.notStrictEqual(newAsset.id, fileAsset.id);
                    return callback();
                  });
                });
              });
            });
          });
        });
      });
    });

    /**
     * Test that verifies that the poller does not remove activities that are linked to the old
     * asset when resubmitting an assignment
     */
    it('does not remove activities linked to the old asset when resubmitting an assignment', function(callback) {
      // Generate a test course with a few users who will make submissions
      getClient(null, function(client1, course, user1) {
        getClient(course, function(client2, course, user2) {

          // Get the actual course object so we can pass it into the poller
          getCourse(course.id, function(dbCourse) {

            // Submit a file
            var assignments = [
              new CanvasAssignment(course.id, [
                new CanvasSubmission(user1.id, 'online_upload', [
                  new CanvasFile('image/jpeg', 'File 1', 'file1.jpg')
                ])
              ])
            ];
            CanvasTestsUtil.mockPollingRequests(dbCourse, [], assignments, []);
            CanvasPoller.handleCourse(dbCourse, function(err) {
              assert.ok(!err);

              // The second user will like the asset and create an activity that's associated with
              // the asset
              AssetsTestsUtil.assertGetAssets(client2, course, null, null, null, 1, function(assets) {
                AssetsTestsUtil.assertLike(client2, course, assets.results[0].id, true, function() {

                  // Get the leaderboard so we can check later that no points were lost
                  UsersTestUtil.assertGetLeaderboard(client2, course, null, null, function(oldLeaderboard) {

                    // The first user now re-submits their assignment
                    assignments[0].submissions[0].attempt++;
                    assignments[0].submissions[0].attachments = [new CanvasFile('image/jpeg', 'File 1-updated', 'file1-updated.jpg')];
                    CanvasTestsUtil.mockPollingRequests(dbCourse, [], assignments, []);
                    CanvasPoller.handleCourse(dbCourse, function(err) {
                      assert.ok(!err);

                      // Verify no activities were lost
                      UsersTestUtil.assertGetLeaderboard(client2, course, null, null, function(newLeaderboard) {
                        assert.deepEqual(newLeaderboard, oldLeaderboard);
                        return callback();
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });

    /**
     * Test that verifies that the poller creates categories for each assignment
     */
    it('creates categories for assignments', function(callback) {
      // Generate a test course with a few users who will make submissions
      getClient(null, function(client1, course, user1) {
        getClient(course, function(client2, course, user2) {
          getClient(course, function(client3, course, user3) {

            // Get the actual course object so we can pass it into the poller
            getCourse(course.id, function(dbCourse) {

              // Poll a few assignments
              var assignment1 = new CanvasAssignment(course.id, [
                new CanvasSubmission(user1.id, 'online_url', 'http://www.ucberkeley.edu')
              ], 'Assignment #1');
              var assignment2 = new CanvasAssignment(course.id, [
                new CanvasSubmission(user2.id, 'online_url', 'http://www.google.com')
              ], 'Assignment #2');
              var assignments = [assignment1, assignment2];
              CanvasTestsUtil.mockPollingRequests(dbCourse, [], assignments, []);
              CanvasPoller.handleCourse(dbCourse, function(err) {
                assert.ok(!err);

                // Assert the categories were synchronized
                CategoriesTestUtil.assertGetCategories(client2, course, 2, function(categories) {
                  var category1 = _.find(categories, {'canvas_assignment_id': assignment1.id});
                  var category2 = _.find(categories, {'canvas_assignment_id': assignment2.id});
                  CategoriesTestUtil.assertCategory(category1, {'expectAssetCount': 1});
                  CategoriesTestUtil.assertCategory(category2, {'expectAssetCount': 1});
                  assert.strictEqual(category1.title, assignment1.name);
                  assert.strictEqual(category2.title, assignment2.name);

                  // Subsequent polls should not result in new categories
                  CanvasTestsUtil.mockPollingRequests(dbCourse, [], assignments, []);
                  CanvasPoller.handleCourse(dbCourse, function(err) {
                    assert.ok(!err);
                    CategoriesTestUtil.assertGetCategories(client2, course, 2, function(categories) {
                      var retrievedCategory1 = _.find(categories, {'canvas_assignment_id': assignment1.id});
                      var retrievedCategory2 = _.find(categories, {'canvas_assignment_id': assignment2.id});
                      CategoriesTestUtil.assertCategory(retrievedCategory1, {'expectedCategory': category1});
                      CategoriesTestUtil.assertCategory(retrievedCategory2, {'expectedCategory': category2});

                      // Assert that updating the name of the assignment causes the category's title to be updated
                      assignment1.name = 'Updated assignment';
                      CanvasTestsUtil.mockPollingRequests(dbCourse, [], assignments, []);
                      CanvasPoller.handleCourse(dbCourse, function(err) {
                        assert.ok(!err);
                        CategoriesTestUtil.assertGetCategories(client2, course, 2, function(categories) {
                          var updatedCategory = _.find(categories, {'canvas_assignment_id': assignment1.id});
                          CategoriesTestUtil.assertCategory(updatedCategory, {'expectAssetCount': 1});
                          assert.strictEqual(updatedCategory.title, assignment1.name);

                          return callback();
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });

    /**
     * Test that verifies that the poller does not recreate deleted categories
     */
    it('does not recreate deleted categories', function(callback) {
      getClient(null, function(client1, course, user1) {
        var instructor = TestsUtil.generateInstructor();
        TestsUtil.getAssetLibraryClient(null, course, instructor, function(instructorClient, course, instructor) {

          // Get the actual course object so we can pass it into the poller
          getCourse(course.id, function(dbCourse) {

            // Poll a few assignments
            var submissions = [
              new CanvasSubmission(user1.id, 'online_url', 'http://www.google.com')
            ];
            var assignment1 = new CanvasAssignment(course.id, submissions, 'Assignment #1');
            var assignment2 = new CanvasAssignment(course.id, [], 'Assignment #2');
            var assignments = [assignment1, assignment2];
            CanvasTestsUtil.mockPollingRequests(dbCourse, [], assignments, []);
            CanvasPoller.handleCourse(dbCourse, function(err) {
              assert.ok(!err);

              // Assert the categories were synchronized
              CategoriesTestUtil.assertGetCategories(instructorClient, course, 2, function(categories) {
                var category1 = _.find(categories, {'canvas_assignment_id': assignment1.id});
                var category2 = _.find(categories, {'canvas_assignment_id': assignment2.id});
                CategoriesTestUtil.assertCategory(category1, {'expectAssetCount': 1});
                CategoriesTestUtil.assertCategory(category2, {'expectAssetCount': 1});
                assert.strictEqual(category1.title, assignment1.name);
                assert.strictEqual(category2.title, assignment2.name);

                // Assert the asset was assigned to the correct category
                AssetsTestsUtil.assertGetAssets(client1, course, null, null, null, 1, function(assets) {
                  AssetsTestsUtil.assertGetAsset(client1, course, assets.results[0].id, null, null, function(asset) {
                    assert.strictEqual(asset.categories.length, 1);
                    assert.strictEqual(asset.categories[0].id, category1.id);

                    // Delete the first category
                    CategoriesTestUtil.assertDeleteCategory(instructorClient, course, category1.id, function() {

                      // Poll the Canvas API again
                      CanvasTestsUtil.mockPollingRequests(dbCourse, [], assignments, []);
                      CanvasPoller.handleCourse(dbCourse, function(err) {
                        assert.ok(!err);

                        // Ensure the category wasn't re-created
                        CategoriesTestUtil.assertGetCategories(instructorClient, course, 1, function(categories) {
                          assert.strictEqual(categories[0].id, category2.id);

                          // Assert the category is unlinked from the asset
                          AssetsTestsUtil.assertGetAsset(client1, course, assets.results[0].id, null, null, function(asset) {
                            assert.strictEqual(asset.categories.length, 0);
                            return callback();
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });

  describe('Discussions', function() {

    /**
     * Test that verifies that activities are created for discussions
     */
    it('creates activities for submissions', function(callback) {
      // Generate a test course with a few users who will add entries
      getClient(null, function(client1, course, user1) {
        getClient(course, function(client2, course, user2) {
          getClient(course, function(client3, course, user3) {

            // Get the actual course object so we can pass it into the poller
            getCourse(course.id, function(dbCourse) {

              // Poll the canvas API but don't return a discussion just yet
              var mockedUsers = [
                CanvasTestsModel.getCanvasUser(user1, course),
                CanvasTestsModel.getCanvasUser(user2, course),
                CanvasTestsModel.getCanvasUser(user3, course)
              ];
              CanvasTestsUtil.mockPollingRequests(dbCourse, mockedUsers, [], []);
              CanvasPoller.handleCourse(dbCourse, function(err) {
                assert.ok(!err);

                // Get all the users, they should all have 0 points
                UsersTestUtil.assertGetLeaderboard(client1, course, 3, false, function(users) {
                  _.each(users, function(user) {
                    assert.strictEqual(user.points, 0);
                  });

                  // Poll the Canvas API and return the discussion
                  var discussion = new CanvasDiscussion(user1);
                  CanvasTestsUtil.mockPollingRequests(dbCourse, mockedUsers, [], [discussion]);
                  CanvasPoller.handleCourse(dbCourse, function(err) {
                    assert.ok(!err);

                    var topicPoints = getActivitiesDefaultPoints('discussion_topic');
                    var entryPoints = getActivitiesDefaultPoints('discussion_entry');
                    var entryGetReplyPoints = getActivitiesDefaultPoints('get_discussion_entry_reply');

                    // The user who created the discussion should've received points
                    UsersTestUtil.assertGetLeaderboard(client1, course, 3, false, function(users) {
                      assert.strictEqual(getUserByName(users, user1.fullName).points, topicPoints);
                      assert.strictEqual(getUserByName(users, user2.fullName).points, 0);
                      assert.strictEqual(getUserByName(users, user3.fullName).points, 0);

                      // Subsequent polls should not result in new activities
                      CanvasTestsUtil.mockPollingRequests(dbCourse, mockedUsers, [], [discussion]);
                      CanvasPoller.handleCourse(dbCourse, function(err) {
                        assert.ok(!err);
                        UsersTestUtil.assertGetLeaderboard(client1, course, 3, false, function(users) {
                          assert.strictEqual(getUserByName(users, user1.fullName).points, topicPoints);
                          assert.strictEqual(getUserByName(users, user2.fullName).points, 0);
                          assert.strictEqual(getUserByName(users, user3.fullName).points, 0);

                          // Add an entry to a discussion
                          discussion.addEntry(new CanvasDiscussionEntry(user2));
                          CanvasTestsUtil.mockPollingRequests(dbCourse, mockedUsers, [], [discussion]);
                          CanvasPoller.handleCourse(dbCourse, function(err) {
                            assert.ok(!err);

                            // The user who added an entry on the discussion should now also have some points
                            UsersTestUtil.assertGetLeaderboard(client1, course, 3, false, function(users) {
                              assert.strictEqual(getUserByName(users, user1.fullName).points, topicPoints);
                              assert.strictEqual(getUserByName(users, user2.fullName).points, entryPoints);
                              assert.strictEqual(getUserByName(users, user3.fullName).points, 0);

                              // Reply to an entry
                              discussion.addEntry(new CanvasDiscussionEntry(user3, discussion.getEntries()[0].id));
                              CanvasTestsUtil.mockPollingRequests(dbCourse, mockedUsers, [], [discussion]);
                              CanvasPoller.handleCourse(dbCourse, function(err) {
                                assert.ok(!err);

                                // The user who replied to an entry should've received some points. The user
                                // who made the original entry will get additional points
                                UsersTestUtil.assertGetLeaderboard(client1, course, 3, false, function(users) {
                                  assert.strictEqual(getUserByName(users, user1.fullName).points, topicPoints);
                                  assert.strictEqual(getUserByName(users, user2.fullName).points, entryPoints + entryGetReplyPoints);
                                  assert.strictEqual(getUserByName(users, user3.fullName).points, entryPoints);

                                  return callback();
                                });
                              });
                            });
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });

    /**
     * Test that verifies that the poller can page the Canvas Discussions REST API
     */
    it('can page Canvas', function(callback) {
      // Generate a test course with a few users who will add entries
      getClient(null, function(client1, course, user1) {
        getClient(course, function(client2, course, user2) {
          getClient(course, function(client3, course, user3) {
            var instructor = TestsUtil.generateInstructor();
            TestsUtil.getAssetLibraryClient(null, course, instructor, function(instructorClient, course, instructor) {

              // Get the actual course object so we can pass it into the poller
              getCourse(course.id, function(dbCourse) {

                // Prepare the mocked requests to Canvas
                var mockedUsers = [
                  CanvasTestsModel.getCanvasUser(user1, course),
                  CanvasTestsModel.getCanvasUser(user2, course),
                  CanvasTestsModel.getCanvasUser(user3, course)
                ];
                var discussions = _.times(100, function(n) {
                  return new CanvasDiscussion(user1);
                });
                CanvasTestsUtil.mockPollingRequests(dbCourse, mockedUsers, [], discussions);

                // Poll the Canvas API for information
                CanvasPoller.handleCourse(dbCourse, function(err) {
                  assert.ok(!err);

                  // The first user made a 100 discussion topics which should result in earning 500 points
                  UsersTestUtil.assertGetLeaderboard(instructorClient, course, 3, false, function(leaderboard) {
                    assert.strictEqual(getUserByName(leaderboard, user1.fullName).points, 100 * getActivitiesDefaultPoints('discussion_topic'));
                    assert.strictEqual(getUserByName(leaderboard, user2.fullName).points, 0);
                    assert.strictEqual(getUserByName(leaderboard, user3.fullName).points, 0);

                    // Add 100 entries
                    _.each(discussions, function(discussion) {
                      discussion.addEntry(new CanvasDiscussionEntry(user2));
                    });
                    CanvasTestsUtil.mockPollingRequests(dbCourse, mockedUsers, [], discussions);

                    // Poll the Canvas API for information
                    CanvasPoller.handleCourse(dbCourse, function(err) {
                      assert.ok(!err);

                      // The second user made a 100 entries which should result in earning 300 points
                      UsersTestUtil.assertGetLeaderboard(instructorClient, course, 3, false, function(leaderboard) {
                        assert.strictEqual(getUserByName(leaderboard, user1.fullName).points, 100 * getActivitiesDefaultPoints('discussion_topic'));
                        assert.strictEqual(getUserByName(leaderboard, user2.fullName).points, 100 * getActivitiesDefaultPoints('discussion_entry'));
                        assert.strictEqual(getUserByName(leaderboard, user3.fullName).points, 0);

                        // Add 100 replies to entries
                        _.each(discussions, function(discussion) {
                          discussion.addEntry(new CanvasDiscussionEntry(user3, discussion.getEntries()[0].id));
                        });
                        CanvasTestsUtil.mockPollingRequests(dbCourse, mockedUsers, [], discussions);

                        // Poll the Canvas API for information
                        CanvasPoller.handleCourse(dbCourse, function(err) {
                          assert.ok(!err);

                          // The third user made a 100 replies which should result in earning 200 points. Additionally
                          // the second user should've received a 100 points extra for getting 100 replies to their entries
                          UsersTestUtil.assertGetLeaderboard(instructorClient, course, 3, false, function(leaderboard) {
                            assert.strictEqual(getUserByName(leaderboard, user1.fullName).points, 100 * getActivitiesDefaultPoints('discussion_topic'));
                            assert.strictEqual(getUserByName(leaderboard, user2.fullName).points, (100 * getActivitiesDefaultPoints('discussion_entry')) + (100 * getActivitiesDefaultPoints('get_discussion_entry_reply')));
                            assert.strictEqual(getUserByName(leaderboard, user3.fullName).points, 100 * getActivitiesDefaultPoints('discussion_entry'));
                            return callback();
                          });
                        });
                      });
                    });
                  });
                });
              });
            });
          });
        });
      });
    });
  });
});
