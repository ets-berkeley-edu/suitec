/**
 * Copyright 2015 UC Berkeley (UCB) Licensed under the
 * Educational Community License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may
 * obtain a copy of the License at
 *
 *     http://opensource.org/licenses/ECL-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an "AS IS"
 * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

var _ = require('lodash');
var config = require('config');
var cookie = require('cookie');
var cookieParser = require('cookie-parser');
var Joi = require('joi');
var url = require('url');

var Collabosphere = require('col-core');
var CollabosphereUtil = require('col-core/lib/util');
var DB = require('col-core/lib/db');
var log = require('col-core/lib/logger')('col-whiteboards');
var UserConstants = require('col-users/lib/constants');

/**
 * Get a whiteboard
 * // TODO: Only load online people and whiteboard content when required
 *
 * @param  {Number}         userId                          The id of the user retrieving the whiteboard
 * @param  {Number}         id                              The id of the whiteboard
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Whiteboard}     callback.whiteboard             The requested whiteboard
 */
var getWhiteboard = module.exports.getWhiteboard = function(userId, id, callback) {
  // Parameter validation
  var validationSchema = Joi.object().keys({
    'userId': Joi.number().required(),
    'id': Joi.number().required()
  });

  var validationResult = Joi.validate({
    'userId': userId,
    'id': id
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the whiteboard from the DB
  // TODO: Verify that the user has access to the whiteboard
  var options = {
    'where': {
      'id': id
    },
    'include': [{
      'model': DB.WhiteboardElement,
      'attributes': ['element']
    }]
  };
  DB.Whiteboard.find(options).complete(function(err, whiteboard) {
    if (err) {
      log.error({'err': err, 'id': id}, 'Failed to get a whiteboard');
      return callback({'code': 500, 'msg': err.message});
    } else if (!whiteboard) {
      log.debug({'err': err, 'id': id}, 'A whiteboard with the specified id could not be found');
      return callback({'code': 404, 'msg': 'A whiteboard with the specified id could not be found'});
    }

    whiteboard = whiteboard.toJSON();

    // Parse the stringified whiteboard elements and return
    // them in a format that can be understood by Fabric.js
    // TODO: Look at `_.map` for this instead
    var whiteboard_elements = [];
    _.each(whiteboard.whiteboard_elements, function(whiteboardElement) {
      whiteboard_elements.push(JSON.parse(whiteboardElement.element));
    });
    whiteboard.whiteboard_elements = whiteboard_elements;

    // Get the online users in the whiteboard
    getOnlineUsers(id, function(err, onlineUsers) {
      if (err) {
        return callback(err);
      }

      // Add the online users onto the whiteboard object
      whiteboard.online = onlineUsers;

      return callback(null, whiteboard);
    });
  });
};

/**
 * Get the whiteboards to which the current user has access in the current course
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {Number}         [limit]                         The maximum number of results to retrieve. Defaults to 10
 * @param  {Number}         [offset]                        The number to start paging from. Defaults to 0
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Object}         callback.whiteboards            The retrieved whiteboards
 * @param  {Number}         callback.whiteboards.total      The total number of whiteboards to which the current user has access in the current course
 * @param  {Whiteboard[]}   callback.whiteboards.results    The paged whiteboard to which the current user has access in the current course
 */
var getWhiteboards = module.exports.getWhiteboards = function(ctx, limit, offset, callback) {
  // Default some parameters
  limit = CollabosphereUtil.getNumberParam(limit, 10, 1, 25);
  offset = CollabosphereUtil.getNumberParam(offset, 0, 0);

  // Parameter validation
  var validationSchema = Joi.object().keys({
    'limit': Joi.number().required(),
    'offset': Joi.number().required()
  });

  var validationResult = Joi.validate({
    'limit': limit,
    'offset': offset
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the whiteboards from the DB
  var options = {
    'where': {
      'course_id': ctx.course.id
    },
    // TODO: Include online count
    'order': [['created_at', 'DESC']],
    'limit': limit,
    'offset': offset
  };
  DB.Whiteboard.findAndCountAll(options).complete(function(err, result) {
    if (err) {
      log.error({'err': err, 'course': ctx.course, 'user': ctx.user}, 'Failed to get the whiteboard to which the current user has access in the current course');
      return callback({'code': 500, 'msg': err.message});
    }

    return callback(null, {
      'total': result.count,
      'results': result.rows
    });
  });
};

/**
 * Create a new whiteboard
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {String}         title                           The title of the whiteboard
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Whiteboard}     callback.whiteboard             The created whiteboard
 */
var createWhiteboard = module.exports.createWhiteboard = function(ctx, title, callback) {
  // Parameter validation
  var validationSchema = Joi.object().keys({
    'title': Joi.string().max(255).required()
  });

  var validationResult = Joi.validate({
    'title': title
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Create the whiteboard in the DB
  var whiteboard = {
    'course_id': ctx.course.id,
    'title': title
  };

  DB.Whiteboard.create(whiteboard).complete(function(err, whiteboard) {
    if (err) {
      log.error({'err': err}, 'Failed to create a new whiteboard');
      return callback({'code': 500, 'msg': err.message});
    }

    return callback(null, whiteboard);
  });
};

/**
 * Get the list of online users for a whiteboard
 *
 * @param  {Number}         whiteboardId                    The id of the whiteboard for which to get the online users
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {User[]}         callback.users                  The online users in the whiteboard
 * @api private
 */
var getOnlineUsers = function(whiteboardId, callback) {
  // Parameter validation
  var validationSchema = Joi.object().keys({
    'whiteboardId': Joi.number().required()
  });

  var validationResult = Joi.validate({
    'whiteboardId': whiteboardId
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the online users from the DB
  var options = {
    'where': {
      'whiteboard_id': whiteboardId
    },
    'attributes': ['user_id'],
    'include': [{
      'model': DB.User,
      'attributes': UserConstants.BASIC_USER_FIELDS
    }]
  };

  DB.WhiteboardSession.findAll(options).complete(function(err, onlineUsers) {
    if (err) {
      log.error({'err': err, 'whiteboard': whiteboardId}, 'Failed to get the online users for a whiteboard');
      return callback({'code': 500, 'msg': err.message});
    }

    // Filter out the duplicate records for those users that have multiple
    // sessions in the same whiteboard
    onlineUsers = _.unique(onlineUsers, function(onlineUser) {
      return onlineUser.user_id;
    });

    return callback(null, onlineUsers);
  });
};

/**
 * Send the list of all online users in a whiteboard to the users in the whiteboard
 *
 * @param  {Number}         whiteboardId                    The id of the whiteboard for which to send an updated list of online users
 * @api private
 */
var notifyOnlineUsers = function(whiteboardId) {
  getOnlineUsers(whiteboardId, function(err, onlineUsers) {
    if (err) {
      return log.error({'err': err}, 'Failed to send the updated list of online users to the users in the whiteboard');
    }

    Collabosphere.appServer.io.sockets.in(whiteboardId).emit('online', onlineUsers);
  });
};

/**
 * Create a new whiteboard session for a specific websocket connection
 *
 * @param  {Socket}         socket                          The socket over which the user is connected
 * @param  {Function}       [callback]                      Standard callback function
 * @param  {Object}         [callback.err]                  An error that occurred, if any
 * @api private
 */
var createWhiteboardSession = function(socket, callback) {
  callback = callback || function() {};

  var validationSchema = Joi.object().keys({
    'socketId': Joi.string().required(),
    'whiteboardId': Joi.number().required(),
    'userId': Joi.number().required()
  });

  var validationResult = Joi.validate({
    'socketId': socket.id,
    'whiteboardId': socket.whiteboard.id,
    'userId': socket.userId
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Create the whiteboard session in the DB
  var whiteboardSession = {
    'socket_id': socket.id,
    'whiteboard_id': socket.whiteboard.id,
    'user_id': socket.userId
  };

  DB.WhiteboardSession.upsert(whiteboardSession).complete(function(err) {
    if (err) {
      log.error({'type': err}, 'Failed to create a whiteboard session');
      return callback({'code': 500, 'msg': err.message});
    }

    // Send the updated list of online users to the users in the whiteboard
    notifyOnlineUsers(socket.whiteboard.id);

    return callback();
  });
};

/**
 * Delete a whiteboard session for a specific websocket connection
 *
 * @param  {String}         socketId                        The unique socket id of the whiteboard session that is being deleted
 * @param  {Function}       [callback]                      Standard callback function
 * @param  {Object}         [callback.err]                  An error that occurred, if any
 * @api private
 */
var deleteWhiteboardSession = function(socketId, callback) {
  callback = callback || function() {};

  var validationSchema = Joi.object().keys({
    'socketId': Joi.string().required()
  });

  var validationResult = Joi.validate({
    'socketId': socketId
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the whiteboard session that is being deleted
  var options = {
    'where': {
      'socket_id': socketId
    }
  };

  DB.WhiteboardSession.find(options).complete(function(err, whiteboardSession) {
    if (err) {
      log.error({'err': err, 'id': id, 'socketId': socketId}, 'Failed to retrieve the whiteboard session to delete');
      return callback({'code': 500, 'msg': err.message});
    } else if (!whiteboardSession) {
      log.debug({'err': err, 'id': id, 'socketId': socketId}, 'The whiteboard session that is being deleted could not be found');
      return callback({'code': 404, 'msg': 'The whiteboard session that is being deleted could not be found'});
    }

    // Delete the whiteboard session from the DB
    whiteboardSession.destroy().complete(function(err) {
      if (err) {
        log.error({'err': err, 'socketId': socketId}, 'Failed to delete a whiteboard session');
        return callback({'code': 500, 'msg': err.message});
      }

      // Send the updated list of online users to the users in the whiteboard
      notifyOnlineUsers(whiteboardSession.whiteboard_id);

      return callback();
    });
  });
};

/**
 * Delete all whiteboard sessions. This is necessary when the server restarts, as all
 * websockets will have disconnect without the disconnect logic being executed
 *
 * @param  {Function}       [callback]                      Standard callback function
 * @param  {Object}         [callback.err]                  An error that occurred, if any
 * @api private
 */
var deleteWhiteboardSessions = function(callback) {
  callback = callback || function() {};

  var options = {
    'truncate': true
  };

  DB.WhiteboardSession.destroy(options).complete(function(err) {
    if (err) {
      log.error({'err': err}, 'Failed to delete all whiteboard session');
      return callback({'code': 500, 'msg': err.message});
    }

    return callback();
  });
};

// Delete all whiteboard sessions when the server starts
deleteWhiteboardSessions();

/* WHITEBOARD ELEMENTS */

/**
 * Store a new element was added to the whiteboard canvas and inform
 * the online users in the whiteboard of the new element
 *
 * @param  {Socket}         socket                          The socket on which the new whiteboard element was sent
 * @param  {Object}         element                         The deserialized whiteboard element that was added
 * @param  {Function}       [callback]                      Standard callback function
 * @param  {Object}         [callback.err]                  An error that occurred, if any
 * @api private
 */
var addWhiteboardElement = function(socket, element, callback) {
  callback = callback || function() {};

  // Notify all online users in the whiteboard that a new whiteboard element was added.
  // This will not send a notification over the socket on which the new element was sent
  socket.broadcast.to(socket.whiteboard.id).emit('addElement', element);

  // Store the new element
  upsertWhiteboardElement(socket, element, callback);
};

/**
 * Store an updated whiteboard canvas element and inform
 * the online users in the whiteboard of the element update
 *
 * @param  {Socket}         socket                          The socket on which the whiteboard element update was sent
 * @param  {Object}         element                         The deserialized updated whiteboard element
 * @param  {Function}       [callback]                      Standard callback function
 * @param  {Object}         [callback.err]                  An error that occurred, if any
 * @api private
 */
var updateWhiteboardElement = function(socket, element, callback) {
  callback = callback || function() {};

  // Notify all online users in the whiteboard that a whiteboard element was updated.
  // This will not send a notification over the socket on which the element update was sent
  socket.broadcast.to(socket.whiteboard.id).emit('updateElement', element);

  // Store the updated element
  upsertWhiteboardElement(socket, element, callback);
};

/**
 * Create a new whiteboard canvas element. If the whiteboard canvas element
 * already exists, it will be updated
 *
 * @param  {Socket}         socket                          The socket on which the whiteboard element creation update was sent
 * @param  {Object}         element                         The deserialized created or updated whiteboard element
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 */
var upsertWhiteboardElement = function(socket, element, callback) {
  // Parameter validation
  var validationSchema = Joi.object().keys({
    'whiteboardId': Joi.number().required(),
    'element': Joi.object().required(),
    'uid': Joi.number().required()
  });

  var validationResult = Joi.validate({
    'whiteboardId': socket.whiteboard.id,
    'element': element,
    'uid': element.uid
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Create or update the whiteboard element in the DB
  var whiteboardElement = {
    'whiteboard_id': socket.whiteboard.id,
    'uid': element.uid,
    'element': JSON.stringify(element)
  };

  DB.WhiteboardElement.upsert(whiteboardElement).complete(function(err) {
    if (err) {
      log.error({'type': err}, 'Failed to create or update a whiteboard element');
      return callback({'code': 500, 'msg': err.message});
    }

    return callback();
  });
};

/**
 * Delete a whiteboard canvas element that was removed and inform
 * the online users in the whiteboard of the removed element
 *
 * @param  {Socket}         socket                          The socket on which the whiteboard element removal was sent
 * @param  {Object}         element                         The deserialized removed whiteboard element
 * @param  {Function}       [callback]                      Standard callback function
 * @param  {Object}         [callback.err]                  An error that occurred, if any
 * @api private
 */
var deleteWhiteboardElement = function(socket, element, callback) {
  callback = callback || function() {};

  // Parameter validation
  var validationSchema = Joi.object().keys({
    'whiteboardId': Joi.number().required(),
    'element': Joi.object().required(),
    'uid': Joi.number().required()
  });

  var validationResult = Joi.validate({
    'whiteboardId': socket.whiteboard.id,
    'element': element,
    'uid': element.uid
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the whiteboard element that is being deleted
  var options = {
    'where': {
      'whiteboard_id': socket.whiteboard.id,
      'uid': element.uid
    }
  };

  DB.WhiteboardElement.find(options).complete(function(err, whiteboardElement) {
    if (err) {
      log.error({'err': err, 'whiteboardId': socket.whiteboard.id, 'uid': element.uid}, 'Failed to retrieve the whiteboard element to delete');
      return callback({'code': 500, 'msg': err.message});
    } else if (!whiteboardElement) {
      log.debug({'err': err, 'whiteboardId': socket.whiteboard.id, 'uid': element.uid}, 'The whiteboard element that is being deleted could not be found');
      return callback({'code': 404, 'msg': 'The whiteboard element that is being deleted could not be found'});
    }

    whiteboardElement.destroy().complete(function(err) {
      if (err) {
        log.error({'err': err, 'whiteboardId': socket.whiteboard.id, 'uid': element.uid}, 'Failed to delete a whiteboard element');
        return callback({'code': 500, 'msg': err.message});
      }

      // Notify all online users in the whiteboard that a whiteboard element was deleted.
      // This will not send a notification over the socket on which the element update was sent
      socket.broadcast.to(socket.whiteboard.id).emit('deleteElement', element);

      return callback();
    });
  });
};

/* WEB SOCKETS */

/**
 * When a user connects over a websocket, add them to the appropriate room based on the
 * whiteboard from which they connected. A record indicating that the user is online in
 * the whiteboard will also be added
 */
Collabosphere.appServer.io.on('connection', function(socket) {
  log.info({'socket': socket.id}, 'Initiating new websocket connection');

  // Extract the API domain and course id from the referer URL, as well
  // as the room to which the user has connected. The expected referer URL
  // format is `http://domain/whiteboards/<whiteboard_id>?api_domain=<api_domain>&course_id=<course_id>`
  var referer = url.parse(socket.handshake.headers.referer, true);
  var apiDomain = referer.query.api_domain;
  var courseId = referer.query.course_id;
  var whiteboardId = referer.pathname.split('/').pop();

  // Extract the user id from the session cookie that was sent along in the socket handshake
  var cookieName = apiDomain + '_' + courseId;
  var sessionCookie = cookie.parse(socket.handshake.headers.cookie)[cookieName];
  var userId = cookieParser.signedCookie(sessionCookie, config.get('cookie.secret'));

  // Verify that the whiteboard exists and the user has access to it
  getWhiteboard(userId, whiteboardId, function(err, whiteboard) {
    if (err) {
      log.error({'socket': socket.id, 'whiteboardId': whiteboardId}, 'Failed to verify websocket connection');
      return socket.disconnect();
    }

    // Store the user id on the socket
    socket.userId = userId;
    // Store the user id on the socket
    socket.whiteboard = whiteboard;

    // Join the room that corresponds to the whiteboard to which the user connected
    socket.join(whiteboardId);

    // Create a whiteboard session for the current socket
    createWhiteboardSession(socket);

    /**
     * Create a new chat message via the websocket
     */
    socket.on('chat', function(body) {
      createChatMessage(socket, body);
    });

    /**
     * A new element was added to the whiteboard canvas
     */
    socket.on('addElement', function(element) {
      log.debug({'socket': socket.id, 'element': element.uid}, 'A new element was added to the whiteboard');
      addWhiteboardElement(socket, element);
    });

    /**
     * A whiteboard canvas element was updated
     */
    socket.on('updateElement', function(element) {
      log.debug({'socket': socket.id, 'element': element.uid}, 'An element on the whiteboard was updated');
      updateWhiteboardElement(socket, element);
    });

    /**
     * A whiteboard canvas element was deleted
     */
    socket.on('deleteElement', function(element) {
      log.debug({'socket': socket.id, 'element': element.uid}, 'An element on the whiteboard was deleted');
      deleteWhiteboardElement(socket, element);
    });

    /**
     * When a user disconnected, they are removed from the room and their online record
     * is deleted as well
     */
    socket.on('disconnect', function() {
      log.info({'socket': socket.id}, 'Websocket connection was disconnected');

      // Leave the room that corresponds to the whiteboard to which the user was in
      socket.leave(whiteboardId);
      // Remove the whiteboard session for the current socket
      deleteWhiteboardSession(socket.id);
    });
  });
});

/* CHAT */

/**
 * Get a chat message.
 * Note that this is a private method that doesn't do any validation
 *
 * @param  {Number}         id                              The id of the chat message to retrieve
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Comment}        callback.chatMessage            The created chat message
 * @param  {User}           callback.chatMessage.user       The user that created the chat message
 * @api private
 */
var getChatMessage = function(id, callback) {
  var options = {
    'where': {
      'id': id
    },
    'include': [{
      'model': DB.User,
      'attributes': UserConstants.BASIC_USER_FIELDS
    }]
  };
  DB.Chat.find(options).complete(function(err, chatMessage) {
    if (err) {
      log.error({'err': err, 'id': id}, 'Failed to retrieve the chat message');
      return callback({'code': 500, 'msg': err.message});
    }

    return callback(null, chatMessage);
  });
};

/**
 * Create a new chat message on a whiteboard. Note that the access to the whiteboard has already been
 * verified when the websocket connection was initiated
 *
 * @param  {Socket}         socket                          The socket on which the chat message has been sent
 * @param  {String}         body                            The body of the chat message
 * @param  {Function}       [callback]                      Standard callback function
 * @param  {Object}         [callback.err]                  An error that occurred, if any
 * @param  {Comment}        [callback.chatMessage]          The created chat message
 * @param  {User}           [callback.chatMessage.user]     The user that created the chat message
 * @api private
 */
var createChatMessage = function(socket, body, callback) {
  callback = callback || function() {};

  // Parameter validation
  var validationSchema = Joi.object().keys({
    'whiteboardId': Joi.number().required(),
    'body': Joi.string().required()
  });

  var validationResult = Joi.validate({
    'whiteboardId': socket.whiteboard.id,
    'body': body
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Create the chat message in the database
  var chatMessage = {
    'whiteboard_id': socket.whiteboard.id,
    'user_id': socket.userId,
    'body': body
  };

  DB.Chat.create(chatMessage).complete(function(err, chatMessage) {
    if (err) {
      log.error({'err': err}, 'Failed to create a new chat message');
      return callback({'code': 500, 'msg': err.message});
    }

    // Retrieve the created chat message, including the associated user
    getChatMessage(chatMessage.id, function(err, chatMessage) {
      if (err) {
        return callback(err);
      }

      // Send the new chat message to all online users in the whiteboard, including
      // the user that has sent the chat message
      Collabosphere.appServer.io.sockets.in(socket.whiteboard.id).emit('chat', chatMessage);

      return callback(null, chatMessage);
    });
  });
};

/**
 * Get the most recent chat messages for a whiteboard
 *
 * @param  {Context}        ctx                             Standard context containing the current user and the current course
 * @param  {Number}         whiteboardId                    The id of the whiteboard for which to get the most chat messages
 * // TODO: Add timestamp
 * @param  {Function}       callback                        Standard callback function
 * @param  {Object}         callback.err                    An error that occurred, if any
 * @param  {Chat[]}         callback.chatMessages           The most recent chat messages
 */
var getChatMessages = module.exports.getChatMessages = function(ctx, whiteboardId, callback) {
  // Parameter validation
  var validationSchema = Joi.object().keys({
    'whiteboardId': Joi.number().required()
  });

  var validationResult = Joi.validate({
    'whiteboardId': whiteboardId
  }, validationSchema);

  if (validationResult.error) {
    return callback({'code': 400, 'msg': validationResult.error.details[0].message});
  }

  // Get the whiteboard for which to retrieve the recent chat messages
  getWhiteboard(ctx.user.id, whiteboardId, function(err, whiteboard) {
    if (err) {
      return callback(err);
    }

    // Get the chat messages from the DB
    var options = {
      'where': {
        'whiteboard_id': whiteboardId
      },
      'order': [['created_at', 'DESC']],
      'limit': 10,
      'include': [
        {
          'model': DB.User,
          'attributes': UserConstants.BASIC_USER_FIELDS
        }
      ]
    };

    DB.Chat.findAll(options).complete(function(err, chatMessages) {
      if (err) {
        log.error({'err': err, 'whiteboard': whiteboardId}, 'Failed to get the recent chat messages for a whiteboard');
        return callback({'code': 500, 'msg': err.message});
      }

      return callback(null, chatMessages);
    });
  });
};
